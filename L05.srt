1
0-1:59:59,500 --> 00:00:02,647

2
00:00:02,647 --> 00:00:03,730
PROFESSOR: Continue today.

3
00:00:03,730 --> 00:00:06,430
We're still in the
spirit of origami.

4
00:00:06,430 --> 00:00:09,430
And we're going to do some
origami design and foldability

5
00:00:09,430 --> 00:00:12,330
again.

6
00:00:12,330 --> 00:00:15,210
There are two main topics
here on the design side

7
00:00:15,210 --> 00:00:19,430
we're going to talk about--
universal hinge patterns, which

8
00:00:19,430 --> 00:00:23,550
are the things that make
underlying this robot, which

9
00:00:23,550 --> 00:00:24,550
I showed in lecture one.

10
00:00:24,550 --> 00:00:25,650
You may recall.

11
00:00:25,650 --> 00:00:28,530
So it's called a
box pleat pattern.

12
00:00:28,530 --> 00:00:31,919
It's a square grid with
alternating diagonal creases.

13
00:00:31,919 --> 00:00:33,460
And the idea with
the robot is you're

14
00:00:33,460 --> 00:00:36,951
constrained to only-- you have
to build the creases ahead

15
00:00:36,951 --> 00:00:37,450
of time.

16
00:00:37,450 --> 00:00:39,940
You can't say, you
can't build one sheet

17
00:00:39,940 --> 00:00:41,584
that can fold
anywhere at anytime.

18
00:00:41,584 --> 00:00:43,000
You want to build
a sheet that can

19
00:00:43,000 --> 00:00:46,950
fold at any of the crease
lines, at the built

20
00:00:46,950 --> 00:00:49,370
crease lines whenever you want.

21
00:00:49,370 --> 00:00:53,360
And so whereas with
something like Origamizer,

22
00:00:53,360 --> 00:00:56,730
every design has a completely
different crease pattern

23
00:00:56,730 --> 00:00:59,180
and it's difficult to
control that, here we

24
00:00:59,180 --> 00:01:00,854
wanted to make one.

25
00:01:00,854 --> 00:01:02,270
It's not exactly
a crease pattern,

26
00:01:02,270 --> 00:01:03,490
because you're not
using all the creases.

27
00:01:03,490 --> 00:01:05,090
It's what we call
a hinge pattern,

28
00:01:05,090 --> 00:01:08,210
all the possible places
you could fold that thing

29
00:01:08,210 --> 00:01:10,020
and make lots of
different shapes

30
00:01:10,020 --> 00:01:12,800
from that one hinge pattern.

31
00:01:12,800 --> 00:01:16,214
So that's the first
part of the lecture.

32
00:01:16,214 --> 00:01:18,630
And the second part of the
lecture will be about hardness.

33
00:01:18,630 --> 00:01:21,050
And we'll see, I think,
four different kinds

34
00:01:21,050 --> 00:01:23,960
of origami problems
which are all NP-hard.

35
00:01:23,960 --> 00:01:25,860
And I'll tell you
what NP-hard means.

36
00:01:25,860 --> 00:01:27,424
And we'll prove all that.

37
00:01:27,424 --> 00:01:28,840
So there are lots
of problems that

38
00:01:28,840 --> 00:01:30,930
are computationally intractable.

39
00:01:30,930 --> 00:01:35,250
And we're going to cluster them
all together into one lecture.

40
00:01:35,250 --> 00:01:38,040
Because it's kind of fun
to see them together.

41
00:01:38,040 --> 00:01:42,280
Mostly we've been talking
about positive results so far.

42
00:01:42,280 --> 00:01:44,420
All right, so let's do
universal hinge patterns.

43
00:01:44,420 --> 00:01:55,266

44
00:01:55,266 --> 00:01:56,390
This is pretty recent work.

45
00:01:56,390 --> 00:01:58,900
It just appeared at the
big origami math conference

46
00:01:58,900 --> 00:02:00,140
this summer.

47
00:02:00,140 --> 00:02:05,870
And its work by Nadia, and me,
and Marty, and Aviv Ovadya,

48
00:02:05,870 --> 00:02:09,539
who I think actually came out
of this class three years ago,

49
00:02:09,539 --> 00:02:10,220
if I recall.

50
00:02:10,220 --> 00:02:15,030
It just took us awhile
to write it all up.

51
00:02:15,030 --> 00:02:17,720
And it's why the robot
has a box pleat pattern.

52
00:02:17,720 --> 00:02:21,640

53
00:02:21,640 --> 00:02:27,150
So the idea is to require that
the crease pattern of whatever

54
00:02:27,150 --> 00:02:36,440
you want to fold must be a
subset of some fixed hinge

55
00:02:36,440 --> 00:02:36,940
pattern.

56
00:02:36,940 --> 00:02:41,020

57
00:02:41,020 --> 00:02:43,810
And the goal is to make one
hinge pattern to rule them

58
00:02:43,810 --> 00:02:46,690
all, one hinge pattern
that you can make anything.

59
00:02:46,690 --> 00:02:49,679
I mean you can't make literally
anything, I don't think.

60
00:02:49,679 --> 00:02:51,220
I was wondering
about this yesterday.

61
00:02:51,220 --> 00:02:55,340
But we're not going to
try to make everything out

62
00:02:55,340 --> 00:02:57,000
of one hinge pattern.

63
00:02:57,000 --> 00:02:58,910
But we want to make
lots of different things

64
00:02:58,910 --> 00:03:01,090
somehow from one hinge pattern.

65
00:03:01,090 --> 00:03:04,860
And here's the theorem
that formalizes

66
00:03:04,860 --> 00:03:06,210
this idea of lots of things.

67
00:03:06,210 --> 00:03:09,150

68
00:03:09,150 --> 00:03:11,860
We're going to take the box
pleat pattern from an n by n.

69
00:03:11,860 --> 00:03:21,720
Grid so that's you take
a square grid, n by n.

70
00:03:21,720 --> 00:03:23,545
And then you fill in
alternating diagonals.

71
00:03:23,545 --> 00:03:36,000

72
00:03:36,000 --> 00:03:39,850
Then that thing
that hinge pattern

73
00:03:39,850 --> 00:03:42,850
can make by using a
subset of those creases,

74
00:03:42,850 --> 00:03:51,020
you can make any polycube

75
00:03:51,020 --> 00:03:56,260
of n cubes.

76
00:03:56,260 --> 00:03:57,660
Sorry, order n cubes.

77
00:03:57,660 --> 00:04:02,550

78
00:04:02,550 --> 00:04:05,216
And what else?

79
00:04:05,216 --> 00:04:06,670
You can even do it seamless.

80
00:04:06,670 --> 00:04:11,920

81
00:04:11,920 --> 00:04:15,324
So a polycube made of n cubes
is just you take n cubes.

82
00:04:15,324 --> 00:04:16,740
And you start
gluing them together

83
00:04:16,740 --> 00:04:20,730
face to face until you
have one connected monster.

84
00:04:20,730 --> 00:04:23,660
And that's a polycube.

85
00:04:23,660 --> 00:04:26,673
So you can make, for
example, I don't know,

86
00:04:26,673 --> 00:04:28,740
all the Tetris pieces.

87
00:04:28,740 --> 00:04:31,080
Tetris pieces would
be four cubes.

88
00:04:31,080 --> 00:04:37,390
Normally they're squares, but
you can 3-dimensionalize them.

89
00:04:37,390 --> 00:04:38,640
That's a four cube polycube.

90
00:04:38,640 --> 00:04:40,680
And you get the general idea.

91
00:04:40,680 --> 00:04:43,240
So this is cool because
there are exponentially

92
00:04:43,240 --> 00:04:45,750
many polycubes with n cubes.

93
00:04:45,750 --> 00:04:48,550
And here is one pattern
that can make all of them.

94
00:04:48,550 --> 00:04:50,630
And if you imagine
some crazy 3D shape,

95
00:04:50,630 --> 00:04:53,770
you can, of course,
approximate it by cubes,

96
00:04:53,770 --> 00:04:56,380
sort of voxelization
is the usual term,

97
00:04:56,380 --> 00:04:58,460
the same way that
we pixelize images.

98
00:04:58,460 --> 00:05:00,680
And then you can make
basically anything

99
00:05:00,680 --> 00:05:03,837
you want up to the resolution
provided by your sheet.

100
00:05:03,837 --> 00:05:05,795
So that's the sense in
which this is universal.

101
00:05:05,795 --> 00:05:12,150

102
00:05:12,150 --> 00:05:15,000
So let's prove that.

103
00:05:15,000 --> 00:05:20,390
It's actually not too hard
to do in at least one way.

104
00:05:20,390 --> 00:05:25,250
The first idea is to build
something called a cube gadget.

105
00:05:25,250 --> 00:05:28,065

106
00:05:28,065 --> 00:05:30,440
We're going to use the idea
of a gadget a lot, especially

107
00:05:30,440 --> 00:05:31,200
in this lecture.

108
00:05:31,200 --> 00:05:33,158
But in general, it's a
useful algorithmic tool.

109
00:05:33,158 --> 00:05:36,770
A gadget is just something
that you reuse many times.

110
00:05:36,770 --> 00:05:38,220
It's like a tool.

111
00:05:38,220 --> 00:05:44,920
And in this case, we're going
to use this folding many times.

112
00:05:44,920 --> 00:05:48,340
At a high level, it's just
a way to fold a single cube.

113
00:05:48,340 --> 00:05:49,930
But it has lots of
nice properties.

114
00:05:49,930 --> 00:05:51,710
So this is a crease pattern.

115
00:05:51,710 --> 00:05:52,710
Red lines are mountains.

116
00:05:52,710 --> 00:05:55,150
Blue dashed lines are valleys.

117
00:05:55,150 --> 00:05:58,550
It folds into this thing,
which you can see is a cube.

118
00:05:58,550 --> 00:06:00,630
Here it's some
semi-transparent material.

119
00:06:00,630 --> 00:06:04,650
And there's some pleats coming
out in the four directions.

120
00:06:04,650 --> 00:06:08,030
But it's basically
a cube on a plane.

121
00:06:08,030 --> 00:06:10,550
So we started with a
plane, a rectangle.

122
00:06:10,550 --> 00:06:12,420
We fold that pattern.

123
00:06:12,420 --> 00:06:16,630
And you get a rectangle
plus a cube sticking out.

124
00:06:16,630 --> 00:06:20,070
OK, so in particular, I can make
a one cube polycube out of this

125
00:06:20,070 --> 00:06:23,640
if I just made this, got
rid of the rectangular part.

126
00:06:23,640 --> 00:06:27,430
But by using this
gadget n times,

127
00:06:27,430 --> 00:06:30,240
I claim I can make
an n cube polycube.

128
00:06:30,240 --> 00:06:33,080
And this kind of a crazy
idea that, so for example,

129
00:06:33,080 --> 00:06:38,169
suppose the starting sheet
was not just a rectangle.

130
00:06:38,169 --> 00:06:40,460
But suppose it was a rectangle
with a cube sticking out

131
00:06:40,460 --> 00:06:42,030
right here.

132
00:06:42,030 --> 00:06:43,450
I could still do this folding.

133
00:06:43,450 --> 00:06:45,450
Because this folding
didn't touch. The gray lines

134
00:06:45,450 --> 00:06:46,360
are not creases.

135
00:06:46,360 --> 00:06:47,770
They're just hinges.

136
00:06:47,770 --> 00:06:50,980
If I had a cube sticking out
here. and I folded this thing,

137
00:06:50,980 --> 00:06:53,420
it would now be a rectangle
with a cube in the center

138
00:06:53,420 --> 00:06:55,140
and a cube sticking
out of this corner.

139
00:06:55,140 --> 00:06:58,340
Because that corner just
folds to right there.

140
00:06:58,340 --> 00:07:01,417
In fact, I could have a cube
sticking out right here also.

141
00:07:01,417 --> 00:07:03,250
And then there'd be a
cube sticking out here

142
00:07:03,250 --> 00:07:04,680
in the finished product.

143
00:07:04,680 --> 00:07:08,180
And the idea is to just
keep using this gadget.

144
00:07:08,180 --> 00:07:10,350
And make your sheet
bumpier and bumpier

145
00:07:10,350 --> 00:07:12,812
with more and more
cubes sticking out.

146
00:07:12,812 --> 00:07:14,690
And this is the
sort of thing if you

147
00:07:14,690 --> 00:07:16,540
wanted to make-- so
there I had cubes

148
00:07:16,540 --> 00:07:18,764
that were separated
from each other.

149
00:07:18,764 --> 00:07:21,180
If you want to have cubes that
are attached to each other,

150
00:07:21,180 --> 00:07:23,220
you can do that too.

151
00:07:23,220 --> 00:07:28,470
Because all right, say here,
if you apply the cube gadget

152
00:07:28,470 --> 00:07:30,300
at this center
square, so you want

153
00:07:30,300 --> 00:07:33,230
to pull a cube out from there.

154
00:07:33,230 --> 00:07:36,600
Maybe I should show you
in the previous diagram.

155
00:07:36,600 --> 00:07:42,410
So you have these four squares
around the center square

156
00:07:42,410 --> 00:07:47,070
make up the four sides of the
cube, other than the top side.

157
00:07:47,070 --> 00:07:50,610
And so if you already had
a cube on that side face,

158
00:07:50,610 --> 00:07:52,150
when you fold this
thing, you end up

159
00:07:52,150 --> 00:07:56,630
with a cube that has a
cube attached on its right.

160
00:07:56,630 --> 00:07:59,020
So if I wave my hands
enough, I believe

161
00:07:59,020 --> 00:08:01,420
that it's possible to
make anything in this way.

162
00:08:01,420 --> 00:08:05,400
Let me convince you a
little more formally.

163
00:08:05,400 --> 00:08:06,210
Let's see.

164
00:08:06,210 --> 00:08:07,950
Here's a real example.

165
00:08:07,950 --> 00:08:10,060
It gives you an idea of
how you can make even

166
00:08:10,060 --> 00:08:11,600
overhanging cubes.

167
00:08:11,600 --> 00:08:16,380
All I did was initially
I made this first cube.

168
00:08:16,380 --> 00:08:20,110
Then I made this cube with
this one attached to the side,

169
00:08:20,110 --> 00:08:22,070
just like the previous picture.

170
00:08:22,070 --> 00:08:25,530
And then I just made another
cube right underneath that one,

171
00:08:25,530 --> 00:08:28,670
so this cube was already
attached to the center square.

172
00:08:28,670 --> 00:08:31,320
And it just got raised
up by another cube.

173
00:08:31,320 --> 00:08:33,262
So now you've got
this L overhang.

174
00:08:33,262 --> 00:08:34,970
And this is not quite
the crease pattern.

175
00:08:34,970 --> 00:08:37,340
This is there's some lines
that are not drawn here.

176
00:08:37,340 --> 00:08:41,150
But it's a rough sketch
of the crease pattern.

177
00:08:41,150 --> 00:08:43,820
Let's see.

178
00:08:43,820 --> 00:08:45,360
I'll worry about the rest next.

179
00:08:45,360 --> 00:08:48,065
Let me give you a little bit
of an argument why this works.

180
00:08:48,065 --> 00:08:52,540

181
00:08:52,540 --> 00:08:58,210
So a cube gadget
let's say transforms

182
00:08:58,210 --> 00:09:07,140
a constant number of rows
and columns of the grid

183
00:09:07,140 --> 00:09:12,540
into a cube that's
sticking out of your sheet.

184
00:09:12,540 --> 00:09:20,540

185
00:09:20,540 --> 00:09:23,750
And the key property is
it works even if there

186
00:09:23,750 --> 00:09:34,650
are bumps on your
sheet elsewhere.

187
00:09:34,650 --> 00:09:38,360
So when I say elsewhere, let me
show you the cube gadget again.

188
00:09:38,360 --> 00:09:41,920

189
00:09:41,920 --> 00:09:47,000
There's actually two columns
sort of getting used up here.

190
00:09:47,000 --> 00:09:49,710
And there's one row
getting used up there.

191
00:09:49,710 --> 00:09:51,847
Sorry, actually one row here.

192
00:09:51,847 --> 00:09:53,930
So there's one row and two
columns in this corner.

193
00:09:53,930 --> 00:09:56,740
And there's actually one
row and two columns used up

194
00:09:56,740 --> 00:09:57,450
in each corner.

195
00:09:57,450 --> 00:10:00,630
And that material disappears
in some sense from the folding

196
00:10:00,630 --> 00:10:01,800
up here.

197
00:10:01,800 --> 00:10:04,520
But all the other
stuff, this column,

198
00:10:04,520 --> 00:10:07,385
everything out in this
corner, and those four squares

199
00:10:07,385 --> 00:10:09,010
around the center
and the center square

200
00:10:09,010 --> 00:10:11,104
itself, those can
all have bumps.

201
00:10:11,104 --> 00:10:13,270
You better not have bumps
here where I need to fold.

202
00:10:13,270 --> 00:10:15,090
But everywhere else
can have bumps.

203
00:10:15,090 --> 00:10:19,420
And it's OK-- so I just need
to set up my bump pattern so

204
00:10:19,420 --> 00:10:21,830
that when I finish
making that cube,

205
00:10:21,830 --> 00:10:25,040
I have the bumps
in the right place.

206
00:10:25,040 --> 00:10:28,020
So it's sort of a working
backwards process.

207
00:10:28,020 --> 00:10:35,290
And the idea is to
make a tree of cubes.

208
00:10:35,290 --> 00:10:38,510
So if you want to make
something that has cycles in it,

209
00:10:38,510 --> 00:10:42,190
like a big n by n
by n cube array,

210
00:10:42,190 --> 00:10:44,560
you can just cut it
up, subdivide it,

211
00:10:44,560 --> 00:10:47,730
so that it's just
a tree of objects.

212
00:10:47,730 --> 00:10:55,890
So for example, suppose I wanted
to build this shape, which

213
00:10:55,890 --> 00:10:57,360
is not really a tree.

214
00:10:57,360 --> 00:11:04,230
I can just pretend that
there's a slice here.

215
00:11:04,230 --> 00:11:08,360

216
00:11:08,360 --> 00:11:10,440
So these guys are
connected in a path.

217
00:11:10,440 --> 00:11:12,300
But they're not connected here.

218
00:11:12,300 --> 00:11:14,770
In general, you can
just keep slicing

219
00:11:14,770 --> 00:11:19,030
until your thing is
connected like a tree.

220
00:11:19,030 --> 00:11:22,020
Then once you have a tree,
you may know this fact,

221
00:11:22,020 --> 00:11:26,440
every tree has at least two
leaves except in winter.

222
00:11:26,440 --> 00:11:30,890
But in this context,
we're thinking of a tree.

223
00:11:30,890 --> 00:11:33,380
Here the tree is just this path.

224
00:11:33,380 --> 00:11:36,190
And a leaf is a vertex
that has degree one.

225
00:11:36,190 --> 00:11:38,100
And every leaf has
at least, every tree

226
00:11:38,100 --> 00:11:42,450
has at least two leaves
is a fun fact about trees.

227
00:11:42,450 --> 00:11:48,850
And so what we do to make
this thing is make a leaf.

228
00:11:48,850 --> 00:11:51,470
So what I mean is we
start with a blank sheet.

229
00:11:51,470 --> 00:11:53,490
And we'll say OK, here's a leaf.

230
00:11:53,490 --> 00:11:55,340
I'm going to build
that cube first.

231
00:11:55,340 --> 00:11:57,010
So you apply cube gadget.

232
00:11:57,010 --> 00:11:58,750
You build a cube.

233
00:11:58,750 --> 00:12:02,070
Then you effectively
remove that leaf.

234
00:12:02,070 --> 00:12:04,182
Just pretend it was never there.

235
00:12:04,182 --> 00:12:05,640
This is sort of a
conceptual thing.

236
00:12:05,640 --> 00:12:10,300
You're not really removing
it, but and then you repeat.

237
00:12:10,300 --> 00:12:13,600

238
00:12:13,600 --> 00:12:15,300
It's actually a super
simple algorithm.

239
00:12:15,300 --> 00:12:17,650
The details are a
little bit tricky,

240
00:12:17,650 --> 00:12:19,730
because we have to make
sure that this works.

241
00:12:19,730 --> 00:12:25,249
But once I remove that cube,
now my graph is like this.

242
00:12:25,249 --> 00:12:26,040
So I have a choice.

243
00:12:26,040 --> 00:12:30,440
I could either fold this leaf
next, or I could fold this one.

244
00:12:30,440 --> 00:12:31,330
I just keep going.

245
00:12:31,330 --> 00:12:33,740
In this case, I could just
go linearly along the path,

246
00:12:33,740 --> 00:12:36,830
like I did for making
the overhanging L.

247
00:12:36,830 --> 00:12:39,160
And you will make all the cubes.

248
00:12:39,160 --> 00:12:41,861
And the property you'll have is
that whenever I build a cube,

249
00:12:41,861 --> 00:12:43,610
all the things that
were hanging off of it

250
00:12:43,610 --> 00:12:45,410
have already been built.

251
00:12:45,410 --> 00:12:49,010
Because I'm always working
from the leaves up the tree.

252
00:12:49,010 --> 00:12:52,882
This is, for those
who know trees,

253
00:12:52,882 --> 00:12:54,465
this is called a
post-order traversal.

254
00:12:54,465 --> 00:12:59,400

255
00:12:59,400 --> 00:13:02,180
It just means whenever
I touch a node, whenever

256
00:13:02,180 --> 00:13:05,070
I create a node, all
of its descendants, all

257
00:13:05,070 --> 00:13:07,560
of the leaves below it,
have already been built.

258
00:13:07,560 --> 00:13:10,140
And that's exactly how
this thing needs to work.

259
00:13:10,140 --> 00:13:11,854
Because you can have
existing bumps which

260
00:13:11,854 --> 00:13:13,770
are the things that were
attached to that cube

261
00:13:13,770 --> 00:13:16,472
and sort of are
deeper in the tree.

262
00:13:16,472 --> 00:13:17,180
Those are harder.

263
00:13:17,180 --> 00:13:18,310
You can't make those later.

264
00:13:18,310 --> 00:13:19,970
As long as they're
already built,

265
00:13:19,970 --> 00:13:21,750
you just sort of keep
working up the tree.

266
00:13:21,750 --> 00:13:24,000
And the stuff you've
already built hangs off.

267
00:13:24,000 --> 00:13:25,810
In the end, you'll
have your entire tree.

268
00:13:25,810 --> 00:13:28,590
And you'll have your polycube.

269
00:13:28,590 --> 00:13:29,580
That's it.

270
00:13:29,580 --> 00:13:33,220
So there are obviously details
here that I'm skipping.

271
00:13:33,220 --> 00:13:37,830
But I think this is
a fun essence of it.

272
00:13:37,830 --> 00:13:40,290
Another fact, this is
essentially optimal.

273
00:13:40,290 --> 00:13:45,020
So I'm using an n by n grid
to make around n cubes.

274
00:13:45,020 --> 00:13:47,670
You might hope in some
cases you can do better.

275
00:13:47,670 --> 00:13:50,340
In some cases, you can make
n squared cubes out of an n

276
00:13:50,340 --> 00:13:50,880
by n grid.

277
00:13:50,880 --> 00:13:53,010
That's the best case.

278
00:13:53,010 --> 00:13:55,170
The worst case
really is n cubes.

279
00:13:55,170 --> 00:14:01,654
Because if you want to
make a super long polycube,

280
00:14:01,654 --> 00:14:09,140
a one by one by n grid, then
the diameter of this thing

281
00:14:09,140 --> 00:14:10,590
is about n.

282
00:14:10,590 --> 00:14:13,160
And the diameter of my
square paper is like

283
00:14:13,160 --> 00:14:14,680
maybe root 2 times n.

284
00:14:14,680 --> 00:14:16,350
So maybe I could
save a root 2 factor.

285
00:14:16,350 --> 00:14:19,690
But just to get this diameter
n, I'm going to need about an n

286
00:14:19,690 --> 00:14:21,050
by n sheet.

287
00:14:21,050 --> 00:14:22,980
So in the worst case,
this is the best

288
00:14:22,980 --> 00:14:25,040
you can hope for from
our usual diameter

289
00:14:25,040 --> 00:14:27,747
argument like last class.

290
00:14:27,747 --> 00:14:29,080
But sometimes you can do better.

291
00:14:29,080 --> 00:14:36,120
So for example, here is an
MIT made by Aviv Ovadya.

292
00:14:36,120 --> 00:14:39,590
And this is much more
efficient, in some sense

293
00:14:39,590 --> 00:14:43,790
because everything
here is height one.

294
00:14:43,790 --> 00:14:47,530
You can share a lot
of those pleats.

295
00:14:47,530 --> 00:14:50,940
You don't have to waste rows
for every single gadget.

296
00:14:50,940 --> 00:14:53,420
You just, you can
share those wasted rows

297
00:14:53,420 --> 00:14:56,930
along all the guys
who are aligned.

298
00:14:56,930 --> 00:14:59,155
And general picture,
this is actually

299
00:14:59,155 --> 00:15:01,150
Aviv's master's thesis.

300
00:15:01,150 --> 00:15:04,029

301
00:15:04,029 --> 00:15:06,570
The way I described it, if you
wanted to make two cubes right

302
00:15:06,570 --> 00:15:10,310
next to each other, you fold
two separate cube gadgets

303
00:15:10,310 --> 00:15:13,140
that each use up their
rows and columns.

304
00:15:13,140 --> 00:15:15,900
You can be a little bit more
clever like I was saying

305
00:15:15,900 --> 00:15:20,480
and share those used up
rows between the two guys.

306
00:15:20,480 --> 00:15:22,390
Because they are
horizontally aligned.

307
00:15:22,390 --> 00:15:24,310
And it's a little
more efficient.

308
00:15:24,310 --> 00:15:28,530
And that's essentially
what's done in that example.

309
00:15:28,530 --> 00:15:30,450
But there's still some
sort of wastage here.

310
00:15:30,450 --> 00:15:31,825
You don't really
need to do that.

311
00:15:31,825 --> 00:15:35,250
You really want to build
the two by one thing.

312
00:15:35,250 --> 00:15:37,970
And with some fancier version of
the algorithm, you can do that.

313
00:15:37,970 --> 00:15:39,470
If you want to check
it out, you can

314
00:15:39,470 --> 00:15:43,220
see Aviv's M.Eng.
thesis, which

315
00:15:43,220 --> 00:15:46,600
was just completed last month.

316
00:15:46,600 --> 00:15:51,870
And yeah, we don't have a formal
sense in which in how much

317
00:15:51,870 --> 00:15:52,710
better this is.

318
00:15:52,710 --> 00:15:54,882
But it's sort of
opportunistic, tries

319
00:15:54,882 --> 00:15:55,965
to be as good as possible.

320
00:15:55,965 --> 00:15:59,940

321
00:15:59,940 --> 00:16:05,540
And that is one version
of box pleating.

322
00:16:05,540 --> 00:16:09,100
But in the same spirit, I want
to talk about another situation

323
00:16:09,100 --> 00:16:12,540
where we can do very well.

324
00:16:12,540 --> 00:16:16,530
And here we can prove
that we can do very well.

325
00:16:16,530 --> 00:16:19,490
So again, trying to
be more efficient

326
00:16:19,490 --> 00:16:22,250
and this sort of square wasted.

327
00:16:22,250 --> 00:16:23,850
We have n squared of material.

328
00:16:23,850 --> 00:16:25,410
We only make n things.

329
00:16:25,410 --> 00:16:28,720
Be really nice if we could make
n squared things out of an n

330
00:16:28,720 --> 00:16:31,790
by n grid.

331
00:16:31,790 --> 00:16:34,770
And oh, here's another
fun example which uses

332
00:16:34,770 --> 00:16:36,720
all those optimizations
building a car.

333
00:16:36,720 --> 00:16:41,430
This one there's a real version
of, but I don't have it here.

334
00:16:41,430 --> 00:16:46,500
And where we can be particularly
efficient is maze folding.

335
00:16:46,500 --> 00:16:51,100
So suppose you take a
graph on an n by n grid.

336
00:16:51,100 --> 00:16:53,670
Here it happens
not to be square.

337
00:16:53,670 --> 00:16:55,900
And then you just sort
of extrude that graph

338
00:16:55,900 --> 00:16:57,460
out from the sheet.

339
00:16:57,460 --> 00:16:59,250
That would give you
a bunch of walls

340
00:16:59,250 --> 00:17:03,000
in an orthogonal, 3D pattern.

341
00:17:03,000 --> 00:17:07,829
Let's say I extrude by one
unit, one unit of this square.

342
00:17:07,829 --> 00:17:11,040
And I claim I can
fold this 3D shape

343
00:17:11,040 --> 00:17:16,990
from a square of paper
that is just 3n by 3n.

344
00:17:16,990 --> 00:17:19,700
So it's just a constant
factor shrinkage.

345
00:17:19,700 --> 00:17:23,522
And this is essentially the
best you could hope for.

346
00:17:23,522 --> 00:17:25,660
Yeah, should I try to argue it.

347
00:17:25,660 --> 00:17:29,230
So if you look at where did
this material come from,

348
00:17:29,230 --> 00:17:32,110
well you've got to go up
this wall, down this wall,

349
00:17:32,110 --> 00:17:34,060
over the side, up the
wall, down the wall,

350
00:17:34,060 --> 00:17:36,461
over, over, over,
over, up, down.

351
00:17:36,461 --> 00:17:38,210
And in general, you
have to go up and down

352
00:17:38,210 --> 00:17:39,840
and along the floor.

353
00:17:39,840 --> 00:17:45,050
So that's three for every
square that you have here.

354
00:17:45,050 --> 00:17:46,170
So that's maze folding.

355
00:17:46,170 --> 00:17:50,150
And this is work with
Jason Ku and Marty, also

356
00:17:50,150 --> 00:17:54,510
from the big origami
conference this summer.

357
00:17:54,510 --> 00:18:07,190

358
00:18:07,190 --> 00:18:09,000
So you could call it a maze.

359
00:18:09,000 --> 00:18:11,110
You could call it a graph.

360
00:18:11,110 --> 00:18:12,240
But it's orthogonal.

361
00:18:12,240 --> 00:18:13,880
It's on the grid.

362
00:18:13,880 --> 00:18:18,110
And it's extruded from an
n by n square let's say.

363
00:18:18,110 --> 00:18:20,858

364
00:18:20,858 --> 00:18:31,320
And that thing can be
folded from an order n

365
00:18:31,320 --> 00:18:34,430
by order n square of paper.

366
00:18:34,430 --> 00:18:38,420

367
00:18:38,420 --> 00:18:43,664
And if you're extruding by one
unit, this big O at that three.

368
00:18:43,664 --> 00:18:45,080
And to me this is
really exciting.

369
00:18:45,080 --> 00:18:49,450
Because one of the big mysteries
to me in origami design

370
00:18:49,450 --> 00:18:51,940
is in practical origami, you
usually start with a sheet.

371
00:18:51,940 --> 00:18:54,910
And you make something that's
like two or three times smaller

372
00:18:54,910 --> 00:18:56,994
and never much more.

373
00:18:56,994 --> 00:18:59,160
And it would be really nice
to capture theoretically

374
00:18:59,160 --> 00:19:02,630
what things can you make by only
shrinking by a constant factor.

375
00:19:02,630 --> 00:19:05,370
Like checkerboards,
we know, or we think,

376
00:19:05,370 --> 00:19:06,970
you have to shrink a lot.

377
00:19:06,970 --> 00:19:08,470
For an n by n
checkerboard, you have

378
00:19:08,470 --> 00:19:12,080
to shrink by like factor
of n over 2, n over 4,

379
00:19:12,080 --> 00:19:13,590
whatever the best bound is.

380
00:19:13,590 --> 00:19:15,787
But it seems the more
complicated you want,

381
00:19:15,787 --> 00:19:16,870
the more you have to fold.

382
00:19:16,870 --> 00:19:19,350
Here, I can make a
super complicated maze.

383
00:19:19,350 --> 00:19:21,280
It could be a
million by million.

384
00:19:21,280 --> 00:19:25,020
And I'm still only shrinking
the sheet by a factor of three.

385
00:19:25,020 --> 00:19:26,830
So this is one of
the few results

386
00:19:26,830 --> 00:19:29,050
we know where you can
get a large class,

387
00:19:29,050 --> 00:19:33,300
and yet you're only
shrinking by small factor.

388
00:19:33,300 --> 00:19:36,840
The proof of this is also
pretty easy, in fact even easier

389
00:19:36,840 --> 00:19:39,014
than the previous one.

390
00:19:39,014 --> 00:19:40,430
Again, we're going
to use gadgets.

391
00:19:40,430 --> 00:19:44,080
And we're going to combine
them in different ways.

392
00:19:44,080 --> 00:19:48,340
But the idea is we
just make a gadget

393
00:19:48,340 --> 00:19:52,520
for each possible
vertex in this graph.

394
00:19:52,520 --> 00:19:55,070

395
00:19:55,070 --> 00:19:59,840
So a vertex in the graph could
have no edges incident to it.

396
00:19:59,840 --> 00:20:01,655
So we call this degree 0.

397
00:20:01,655 --> 00:20:04,460

398
00:20:04,460 --> 00:20:09,240
Or it could have one incident
edge and the rest are absent.

399
00:20:09,240 --> 00:20:10,780
That's degree 1.

400
00:20:10,780 --> 00:20:12,350
Or it could have
two incident edges.

401
00:20:12,350 --> 00:20:14,141
And there's two ways
it could be like that.

402
00:20:14,141 --> 00:20:16,550
It could be a turn or
it could be straight.

403
00:20:16,550 --> 00:20:20,446

404
00:20:20,446 --> 00:20:21,945
You could have three
incident edges.

405
00:20:21,945 --> 00:20:24,747

406
00:20:24,747 --> 00:20:26,330
Or you could have
four incident edges.

407
00:20:26,330 --> 00:20:29,220

408
00:20:29,220 --> 00:20:30,830
So that's all the
possible vertices

409
00:20:30,830 --> 00:20:32,270
in our orthogonal graph.

410
00:20:32,270 --> 00:20:34,970
And we're just going to make
a crease pattern, a folding

411
00:20:34,970 --> 00:20:38,700
for each one of these and then
just combine them together.

412
00:20:38,700 --> 00:20:42,860
Now it takes a lot of care
in designing those patterns

413
00:20:42,860 --> 00:20:44,880
that they actually fit together.

414
00:20:44,880 --> 00:20:48,470
But all you need to know
is that it can be done.

415
00:20:48,470 --> 00:20:51,950
And they're not trivial.

416
00:20:51,950 --> 00:20:54,080
But once you have
them, it's easy.

417
00:20:54,080 --> 00:20:56,050
So you've got
degree 0 on the top,

418
00:20:56,050 --> 00:21:00,750
degree 2 straight, degree 4,
degree 3, degree 1, degree 2

419
00:21:00,750 --> 00:21:02,130
turn.

420
00:21:02,130 --> 00:21:05,710
And they're at, I guess, an
increasing order of difficulty.

421
00:21:05,710 --> 00:21:08,740
And we need to know
that these things exist.

422
00:21:08,740 --> 00:21:10,760
One way is to in some
sense just to draw

423
00:21:10,760 --> 00:21:12,380
the picture of the folded state.

424
00:21:12,380 --> 00:21:15,030
But there's so many layers
here it's a little hard to see,

425
00:21:15,030 --> 00:21:18,450
and so in order to really
prove that these things exist,

426
00:21:18,450 --> 00:21:20,860
Jason drew diagrams of how
these things could actually

427
00:21:20,860 --> 00:21:22,959
be folded in isolation.

428
00:21:22,959 --> 00:21:25,250
In some sense, we only care
about this final 3D picture

429
00:21:25,250 --> 00:21:27,680
in knowing that it works and is
non self-intersecting and all

430
00:21:27,680 --> 00:21:28,180
that.

431
00:21:28,180 --> 00:21:31,210
But to show that
these exist, one way

432
00:21:31,210 --> 00:21:34,580
is to actually
build them or show

433
00:21:34,580 --> 00:21:37,180
the sequence that got there.

434
00:21:37,180 --> 00:21:39,112
But in reality, you
wouldn't fold it this way.

435
00:21:39,112 --> 00:21:41,320
Because what you do is you
take these crease patterns

436
00:21:41,320 --> 00:21:44,730
on the left and just start
pasting them together.

437
00:21:44,730 --> 00:21:46,700
It's like a big
cut and paste job.

438
00:21:46,700 --> 00:21:51,310
So you say, oh well maybe like
if I made the square of turns,

439
00:21:51,310 --> 00:21:54,640
I would just take one of
these, copy, rotate, put it

440
00:21:54,640 --> 00:21:57,650
here, copy, rotate, put it
here, copy, rotate, put it here.

441
00:21:57,650 --> 00:22:00,270
And that would make
a square of turns.

442
00:22:00,270 --> 00:22:01,870
And what you need
for that to work

443
00:22:01,870 --> 00:22:04,881
is that the interfaces
here are compatible.

444
00:22:04,881 --> 00:22:06,630
You can think of it
in the crease pattern,

445
00:22:06,630 --> 00:22:08,660
or you can think of
it in the 3D state.

446
00:22:08,660 --> 00:22:11,390
The interface in all
of these pictures

447
00:22:11,390 --> 00:22:15,102
is that when you have an
actual edge that's raised,

448
00:22:15,102 --> 00:22:15,810
it's very simple.

449
00:22:15,810 --> 00:22:18,800
It just goes over,
up, down, over.

450
00:22:18,800 --> 00:22:21,970
And when you have an edge that
doesn't exist, you go over

451
00:22:21,970 --> 00:22:24,290
and then you have
a pleat underneath.

452
00:22:24,290 --> 00:22:26,480
And then you go over.

453
00:22:26,480 --> 00:22:29,130
And it's important that those
are the same total length.

454
00:22:29,130 --> 00:22:32,300
Because you need to be
able to choose whether it's

455
00:22:32,300 --> 00:22:34,880
a raised edge or
a non-raised edge.

456
00:22:34,880 --> 00:22:37,310
And because all of those
interfaces are the same,

457
00:22:37,310 --> 00:22:39,810
all of the down edges are
this kind of double pleat.

458
00:22:39,810 --> 00:22:42,900
And all of the up edges
are just the ridge.

459
00:22:42,900 --> 00:22:44,320
These things fit together.

460
00:22:44,320 --> 00:22:46,531
And you can see that in
the crease pattern also.

461
00:22:46,531 --> 00:22:47,905
Here's what the
pleat looks like.

462
00:22:47,905 --> 00:22:50,320
And it can match with
this pleat or this one.

463
00:22:50,320 --> 00:22:51,690
You can rotate.

464
00:22:51,690 --> 00:22:53,610
Here is the ridge.

465
00:22:53,610 --> 00:22:58,420
It just goes up and back down.

466
00:22:58,420 --> 00:23:00,780
And you just paste
those together.

467
00:23:00,780 --> 00:23:03,860
And you get your
desired crease pattern.

468
00:23:03,860 --> 00:23:05,520
So here's a simple example.

469
00:23:05,520 --> 00:23:08,310
The graph has almost all the
vertices, everything except 0

470
00:23:08,310 --> 00:23:11,300
I think, and straights.

471
00:23:11,300 --> 00:23:13,490
All right, not
quite all of them.

472
00:23:13,490 --> 00:23:15,420
But I've color coded here.

473
00:23:15,420 --> 00:23:16,780
So like you take the graph.

474
00:23:16,780 --> 00:23:18,780
You just embed it on a
slightly larger grid.

475
00:23:18,780 --> 00:23:21,180
And you replace each
of those vertices

476
00:23:21,180 --> 00:23:23,150
with the crease pattern
that makes that thing.

477
00:23:23,150 --> 00:23:25,640
You just have to rotate
it for it to work out.

478
00:23:25,640 --> 00:23:28,080
And then you see that
all of these creases

479
00:23:28,080 --> 00:23:30,000
just meet up correctly.

480
00:23:30,000 --> 00:23:33,954
And then that's your crease
pattern, which will fold this.

481
00:23:33,954 --> 00:23:35,370
So that once you
have the gadgets,

482
00:23:35,370 --> 00:23:37,830
the algorithm is super
simple, just a bunch

483
00:23:37,830 --> 00:23:40,790
of cutting and pasting.

484
00:23:40,790 --> 00:23:42,510
And you can do more
complicated examples.

485
00:23:42,510 --> 00:23:44,040
Here's an actual maze.

486
00:23:44,040 --> 00:23:47,140

487
00:23:47,140 --> 00:23:49,950
Get some pretty complicated
crease patterns.

488
00:23:49,950 --> 00:23:52,060
Not so easy to fold.

489
00:23:52,060 --> 00:23:54,550
But it can be done.

490
00:23:54,550 --> 00:23:56,300
I didn't bring the
physical model of this,

491
00:23:56,300 --> 00:23:58,258
because it actually looks
better in photograph.

492
00:23:58,258 --> 00:24:00,740

493
00:24:00,740 --> 00:24:01,470
It's a challenge.

494
00:24:01,470 --> 00:24:04,940
This was folded by an
undergrad here, Chris Chin.

495
00:24:04,940 --> 00:24:07,890
And in fact, it's such
an easy an algorithm,

496
00:24:07,890 --> 00:24:09,945
I implemented it as
a web application.

497
00:24:09,945 --> 00:24:11,730
It runs in JavaScript.

498
00:24:11,730 --> 00:24:14,000
And you can go play with it.

499
00:24:14,000 --> 00:24:17,370
It's
erikdemaine.org/fonts/maze

500
00:24:17,370 --> 00:24:19,540
And you can say, OK
give me a random maze.

501
00:24:19,540 --> 00:24:21,667
And you get a 3D representation.

502
00:24:21,667 --> 00:24:23,000
And you get your crease pattern.

503
00:24:23,000 --> 00:24:23,700
You hit print.

504
00:24:23,700 --> 00:24:25,770
It will print out this
part in vector forms,

505
00:24:25,770 --> 00:24:28,530
nice high resolution,
and all that.

506
00:24:28,530 --> 00:24:29,920
You can make more mazes.

507
00:24:29,920 --> 00:24:31,800
If you really want to
make a particular maze,

508
00:24:31,800 --> 00:24:34,590
you can fool around with that.

509
00:24:34,590 --> 00:24:37,500
And you can also write
important messages

510
00:24:37,500 --> 00:24:45,690
like something like that.

511
00:24:45,690 --> 00:24:50,020
And then you get this
3D representation,

512
00:24:50,020 --> 00:24:53,570
which you can fold by this
simple crease pattern.

513
00:24:53,570 --> 00:24:55,680
If you make that, one
please send it to me.

514
00:24:55,680 --> 00:25:02,156
But that may take several hours
and use a big sheet of paper.

515
00:25:02,156 --> 00:25:04,280
I mean, you're only shrinking
by a constant factor.

516
00:25:04,280 --> 00:25:05,990
How hard could it be?

517
00:25:05,990 --> 00:25:08,420
The answer is quite hard,
because the gadgets interact.

518
00:25:08,420 --> 00:25:11,100
It's tricky.

519
00:25:11,100 --> 00:25:13,230
All right, that's maze folding.

520
00:25:13,230 --> 00:25:16,490
Any questions about maze
folding or this stuff?

521
00:25:16,490 --> 00:25:19,320
I think that's the end of
positive results for today.

522
00:25:19,320 --> 00:25:20,680
And we move into NP-hardness.

523
00:25:20,680 --> 00:25:23,435

524
00:25:23,435 --> 00:25:23,935
Good?

525
00:25:23,935 --> 00:25:26,930

526
00:25:26,930 --> 00:25:32,480
All right, well every
origamist knows,

527
00:25:32,480 --> 00:25:34,560
and if you've been
working on a problem set,

528
00:25:34,560 --> 00:25:38,480
you should know by
now origami is hard.

529
00:25:38,480 --> 00:25:41,930
And we'd like to
prove that formally.

530
00:25:41,930 --> 00:25:45,510
And because we're
computer scientists,

531
00:25:45,510 --> 00:25:50,260
we like to know what we
can't know essentially.

532
00:25:50,260 --> 00:25:55,046

533
00:25:55,046 --> 00:25:56,420
There are a lot
of problems where

534
00:25:56,420 --> 00:25:58,340
there's no efficient algorithm.

535
00:25:58,340 --> 00:26:00,510
And instead of
just giving up, we

536
00:26:00,510 --> 00:26:04,020
like to prove that no one can
find an efficient algorithm.

537
00:26:04,020 --> 00:26:06,580
Because then we know
we're kind of done.

538
00:26:06,580 --> 00:26:09,140
That's comforting.

539
00:26:09,140 --> 00:26:14,832
And NP-hardness,
let me change this,

540
00:26:14,832 --> 00:26:16,290
I don't want to
formally define it.

541
00:26:16,290 --> 00:26:18,410
Because it's a
little bit technical.

542
00:26:18,410 --> 00:26:20,780
But a working
definition, there are

543
00:26:20,780 --> 00:26:24,170
lots of working definitions
that are super easy to tell you.

544
00:26:24,170 --> 00:26:28,330

545
00:26:28,330 --> 00:26:31,990
So the informal version
is that NP-hard problems

546
00:26:31,990 --> 00:26:36,200
are computationally
intractable problems,

547
00:26:36,200 --> 00:26:39,540
meaning there's no tractable
way, no efficient way, to solve

548
00:26:39,540 --> 00:26:41,080
it on a computer.

549
00:26:41,080 --> 00:26:47,630
But what it really means,
or what it really implies,

550
00:26:47,630 --> 00:27:00,740
is, if a problem is NP-hard, then
there's no efficient algorithm.

551
00:27:00,740 --> 00:27:02,816
I wish we could just say that.

552
00:27:02,816 --> 00:27:13,740
But there's a slight
catch, unless P = NP.

553
00:27:13,740 --> 00:27:18,200
How many people know
about NP-hardness?

554
00:27:18,200 --> 00:27:20,540
Well, how many people don't?

555
00:27:20,540 --> 00:27:21,040
Just a few.

556
00:27:21,040 --> 00:27:24,290
All right, I'm going to go
relatively quickly then.

557
00:27:24,290 --> 00:27:27,540
Those who haven't heard
NP-hardness and haven't heard

558
00:27:27,540 --> 00:27:29,890
of P=NP?

559
00:27:29,890 --> 00:27:30,390
Good.

560
00:27:30,390 --> 00:27:32,560
So you've all heard about
this famous problem.

561
00:27:32,560 --> 00:27:38,880
It's almost certainly the
case that P does not equal NP.

562
00:27:38,880 --> 00:27:40,920
Pretty much everyone
believes that,

563
00:27:40,920 --> 00:27:46,440
unless you watch my April Fool's
video. (Search for P equals

564
00:27:46,440 --> 00:27:49,670
NP on YouTube.)

565
00:27:49,670 --> 00:27:55,940
And what this means intuitively
is that there's no cheating.

566
00:27:55,940 --> 00:27:59,822
There's no trick to make
lucky guesses in life.

567
00:27:59,822 --> 00:28:02,030
If you've got two choices
and you don't know which is

568
00:28:02,030 --> 00:28:06,530
the right choice,
and you're computer,

569
00:28:06,530 --> 00:28:09,240
you can't-- computers
aren't lucky.

570
00:28:09,240 --> 00:28:11,920
The best they can do
is try both options.

571
00:28:11,920 --> 00:28:14,460
That's what P does not
equal NP means basically.

572
00:28:14,460 --> 00:28:17,590
There are no lucky, there's
no way to simulate luckiness.

573
00:28:17,590 --> 00:28:19,640
That's the technical version.

574
00:28:19,640 --> 00:28:22,210

575
00:28:22,210 --> 00:28:24,310
Those who know NP
should agree with me.

576
00:28:24,310 --> 00:28:24,980
That is real.

577
00:28:24,980 --> 00:28:29,573

578
00:28:29,573 --> 00:28:31,710
It's not how most
people explain it.

579
00:28:31,710 --> 00:28:35,190
But it's how I like
to think about it.

580
00:28:35,190 --> 00:28:38,030
And from that perspective,
it's kind of obvious.

581
00:28:38,030 --> 00:28:39,880
But it's very annoying.

582
00:28:39,880 --> 00:28:44,600
It's unlikely anyone will
prove this in the near future,

583
00:28:44,600 --> 00:28:47,400
says Scott Aaronson,
who bet $200,000

584
00:28:47,400 --> 00:28:50,820
that that was the case.

585
00:28:50,820 --> 00:28:51,320
Right.

586
00:28:51,320 --> 00:28:54,639

587
00:28:54,639 --> 00:28:56,930
So you don't need to know
the definition of NP-hardness

588
00:28:56,930 --> 00:29:00,630
except that it probably means
there's no efficient algorithm.

589
00:29:00,630 --> 00:29:03,890
For what we need here is
this idea of reduction,

590
00:29:03,890 --> 00:29:08,660
that we can take some
hard problem, known

591
00:29:08,660 --> 00:29:09,650
NP-hard problems.

592
00:29:09,650 --> 00:29:12,190
Why did I write "ness" there?

593
00:29:12,190 --> 00:29:16,590
NP-hard problems
show that a problem

594
00:29:16,590 --> 00:29:19,090
that we care about,
like origami design,

595
00:29:19,090 --> 00:29:21,860
is even harder than
those problems.

596
00:29:21,860 --> 00:29:23,620
Therefore, it's also NP-hard.

597
00:29:23,620 --> 00:29:25,389
That's the usual
way for NP-hardness.

598
00:29:25,389 --> 00:29:27,930
It's always showing that your
problem is harder than another.

599
00:29:27,930 --> 00:29:29,180
Or showing that one
of these problems

600
00:29:29,180 --> 00:29:30,450
is easier than your problem.

601
00:29:30,450 --> 00:29:32,230
And therefore, yours is harder.

602
00:29:32,230 --> 00:29:34,650
So I'm going to need
three problems today.

603
00:29:34,650 --> 00:29:37,820
I'll start just by defining two
of them, which you've probably

604
00:29:37,820 --> 00:29:39,090
seen before.

605
00:29:39,090 --> 00:29:40,800
One is called Partition.

606
00:29:40,800 --> 00:29:44,600

607
00:29:44,600 --> 00:29:45,920
And I give you n numbers.

608
00:29:45,920 --> 00:29:48,550

609
00:29:48,550 --> 00:29:53,190
I want to know, can I split
them into equal halves?

610
00:29:53,190 --> 00:30:06,684

611
00:30:06,684 --> 00:30:07,725
Be a little more precise.

612
00:30:07,725 --> 00:30:11,808

613
00:30:11,808 --> 00:30:13,800
Two halves of equal sum.

614
00:30:13,800 --> 00:30:17,600

615
00:30:17,600 --> 00:30:20,840
So suppose you're playing
video game Team Deathmatch.

616
00:30:20,840 --> 00:30:22,230
You've got two teams.

617
00:30:22,230 --> 00:30:23,870
You've got a ranking
for every player.

618
00:30:23,870 --> 00:30:25,900
You'd like to divide
your players so

619
00:30:25,900 --> 00:30:28,327
that the sum of the
rankings on the red side

620
00:30:28,327 --> 00:30:30,660
is the same as the sum of the
rankings on the blue side,

621
00:30:30,660 --> 00:30:33,590
so it's an even game,
more fun, whatever.

622
00:30:33,590 --> 00:30:35,240
This problem, sadly, is NP-hard.

623
00:30:35,240 --> 00:30:37,415
There's no way to do
that, even approximately.

624
00:30:37,415 --> 00:30:40,070

625
00:30:40,070 --> 00:30:42,640
The only catch is this
problem is hard only

626
00:30:42,640 --> 00:30:45,810
when these integers
are super big,

627
00:30:45,810 --> 00:30:47,830
like exponentially large in n.

628
00:30:47,830 --> 00:30:51,681
This problem is
called weakly NP-hard.

629
00:30:51,681 --> 00:30:53,930
So as long as your player
rankings are nice and small,

630
00:30:53,930 --> 00:30:56,230
there actually is an
efficient way to solve that.

631
00:30:56,230 --> 00:30:59,290
Problem but when the integers
are big, this is NP-hard.

632
00:30:59,290 --> 00:31:03,272

633
00:31:03,272 --> 00:31:06,960
An even nastier problem
is satisfiability, or SAT.

634
00:31:06,960 --> 00:31:10,380

635
00:31:10,380 --> 00:31:12,040
Here you're given
some Boolean formula.

636
00:31:12,040 --> 00:31:16,810

637
00:31:16,810 --> 00:31:20,050
So it has a bunch
variables, like x AND y.

638
00:31:20,050 --> 00:31:23,250

639
00:31:23,250 --> 00:31:24,410
You can do AND.

640
00:31:24,410 --> 00:31:27,160
You can do NOT.

641
00:31:27,160 --> 00:31:30,340
And you can do OR, let's say.

642
00:31:30,340 --> 00:31:34,000
That's all you need,
x AND NOT y OR z.

643
00:31:34,000 --> 00:31:37,820
And you want to know, can
I make that formula true?

644
00:31:37,820 --> 00:31:48,310
Is there some setting to
the variables x, y, and z,

645
00:31:48,310 --> 00:31:53,440
or in general there's
n variables, so

646
00:31:53,440 --> 00:31:54,490
that the formula is true?

647
00:31:54,490 --> 00:31:59,800

648
00:31:59,800 --> 00:32:03,250
So we'd say the
formula's satisfied.

649
00:32:03,250 --> 00:32:04,240
And that's NP-hard.

650
00:32:04,240 --> 00:32:06,812
And here there's not even
any numbers to make it hard.

651
00:32:06,812 --> 00:32:08,520
So we call this problem
strongly NP-hard.

652
00:32:08,520 --> 00:32:14,950

653
00:32:14,950 --> 00:32:18,120
And this is really the
prototypical hard problem,

654
00:32:18,120 --> 00:32:22,280
NP-hard problem, it's the very
first one to be proved NP-hard.

655
00:32:22,280 --> 00:32:24,150
It's the only one
really that we usually

656
00:32:24,150 --> 00:32:27,420
prove without a
reduction, you could say.

657
00:32:27,420 --> 00:32:31,230

658
00:32:31,230 --> 00:32:34,940
So what we're going to do it
for four different origami

659
00:32:34,940 --> 00:32:40,685
problems is show those problems
are easier than our problems.

660
00:32:40,685 --> 00:32:45,720

661
00:32:45,720 --> 00:32:47,900
Therefore, our problems
are NP-hard also.

662
00:32:47,900 --> 00:32:54,970

663
00:32:54,970 --> 00:32:57,920
How do we show that,
say Partition

664
00:32:57,920 --> 00:33:00,470
is easier than some problem?

665
00:33:00,470 --> 00:33:03,770
Well, we just take a Parti--
we show that Partition

666
00:33:03,770 --> 00:33:05,597
is a special case
of our problem.

667
00:33:05,597 --> 00:33:06,430
It's a special case.

668
00:33:06,430 --> 00:33:07,930
Clearly it's easier.

669
00:33:07,930 --> 00:33:11,140
So to show that, we take one
of these Partition problems,

670
00:33:11,140 --> 00:33:12,490
like n integers.

671
00:33:12,490 --> 00:33:15,350
We want to know whether you
can split them in equal halves.

672
00:33:15,350 --> 00:33:17,860
I'm going to convert
that into my problem,

673
00:33:17,860 --> 00:33:20,290
so that that problem has
a yes answer if and only

674
00:33:20,290 --> 00:33:22,120
if the Partition problem
has a yes answer.

675
00:33:22,120 --> 00:33:25,250
Therefore, really this
problem becomes a special case

676
00:33:25,250 --> 00:33:26,250
of the one I care about.

677
00:33:26,250 --> 00:33:29,720
Therefore, that problem
is harder, and therefore

678
00:33:29,720 --> 00:33:30,530
also NP-hard.

679
00:33:30,530 --> 00:33:33,060

680
00:33:33,060 --> 00:33:39,310
So I'm going to start out with
a super simple example which

681
00:33:39,310 --> 00:33:43,230
we did in the problem
session on Monday.

682
00:33:43,230 --> 00:33:48,010
Someone posed this to me after
class last week, I think.

683
00:33:48,010 --> 00:33:50,860

684
00:33:50,860 --> 00:33:54,320
I think two lectures ago.

685
00:33:54,320 --> 00:33:57,600
So here's a problem.

686
00:33:57,600 --> 00:34:00,860
I give you a single-vertex
hinge pattern.

687
00:34:00,860 --> 00:34:06,170

688
00:34:06,170 --> 00:34:09,130
Someone built some crazy
robot with some crazy pattern

689
00:34:09,130 --> 00:34:11,310
of hinges all around
a single vertex.

690
00:34:11,310 --> 00:34:15,880
You want to know, can I
make anything out of it?

691
00:34:15,880 --> 00:34:18,650
Does some subset
of those hinges,

692
00:34:18,650 --> 00:34:21,830
if I take that as a
crease pattern, fold flat?

693
00:34:21,830 --> 00:34:26,350

694
00:34:26,350 --> 00:34:28,810
Who posed this problem?

695
00:34:28,810 --> 00:34:30,600
Anybody remember?

696
00:34:30,600 --> 00:34:31,100
All right.

697
00:34:31,100 --> 00:34:32,480
Maybe he's not here.

698
00:34:32,480 --> 00:34:34,400
I forgot, unfortunately.

699
00:34:34,400 --> 00:34:37,429
He asked me, so what
about this problem?

700
00:34:37,429 --> 00:34:39,560
I said, yeah it's
obviously NP-hard.

701
00:34:39,560 --> 00:34:42,020
And we thought about
it for five minutes.

702
00:34:42,020 --> 00:34:44,946
And then after five minutes,
it's obviously NP-hard.

703
00:34:44,946 --> 00:34:50,920
So let me show you the
obvious proof once we have it.

704
00:34:50,920 --> 00:34:52,929
We're going to show
that this problem is

705
00:34:52,929 --> 00:34:54,570
harder than Partition.

706
00:34:54,570 --> 00:34:57,930
So we take n integers, want
to know how to divide them.

707
00:34:57,930 --> 00:35:00,970
And it's really simple.

708
00:35:00,970 --> 00:35:02,785
So suppose someone
gives us n integers.

709
00:35:02,785 --> 00:35:06,320

710
00:35:06,320 --> 00:35:08,950
For integers, we're
going to scale them

711
00:35:08,950 --> 00:35:15,460
all by the same scale factor,
so that their sum equals

712
00:35:15,460 --> 00:35:18,507
360 degrees.

713
00:35:18,507 --> 00:35:20,090
And now, lo and
behold, those integers

714
00:35:20,090 --> 00:35:23,370
are angles in a crease
pattern, in a hinge pattern.

715
00:35:23,370 --> 00:35:25,190
So you just take those numbers.

716
00:35:25,190 --> 00:35:26,010
You turn them.

717
00:35:26,010 --> 00:35:27,140
You put them on a wheel.

718
00:35:27,140 --> 00:35:31,170

719
00:35:31,170 --> 00:35:31,670
OK.

720
00:35:31,670 --> 00:35:34,841
Now presumably, it's not a flat,
foldable, single vertex crease

721
00:35:34,841 --> 00:35:35,340
pattern.

722
00:35:35,340 --> 00:35:36,964
Otherwise, the
answer would be yes.

723
00:35:36,964 --> 00:35:38,880
We want to know, can I
remove some the creases

724
00:35:38,880 --> 00:35:40,736
to make it flat foldable?

725
00:35:40,736 --> 00:35:43,910
Now if you think about
Kawasaki's theorem,

726
00:35:43,910 --> 00:35:46,869
the sum, the alternating
sum of angles equals 0.

727
00:35:46,869 --> 00:35:48,160
Remember how that proof worked?

728
00:35:48,160 --> 00:35:50,760
We said, OK you follow
one angle for a while.

729
00:35:50,760 --> 00:35:51,370
Then you turn.

730
00:35:51,370 --> 00:35:52,078
Then you go back.

731
00:35:52,078 --> 00:35:55,960
And somehow, you have to end
up back where you started.

732
00:35:55,960 --> 00:35:57,350
That's the equals zero part.

733
00:35:57,350 --> 00:35:59,696
And it's the
alternating sum part.

734
00:35:59,696 --> 00:36:01,820
Now in this case, we have
a choice at every crease.

735
00:36:01,820 --> 00:36:04,040
We could include it or not.

736
00:36:04,040 --> 00:36:06,000
If we include the
crease, we turn around.

737
00:36:06,000 --> 00:36:09,810
If we remove the crease,
we keep going straight.

738
00:36:09,810 --> 00:36:12,720
So now the problem is I
give you all these integers.

739
00:36:12,720 --> 00:36:14,320
And I can go right.

740
00:36:14,320 --> 00:36:15,320
And now I have a choice.

741
00:36:15,320 --> 00:36:18,980
Do I go right or left by
the next integer, theta_2.

742
00:36:18,980 --> 00:36:21,627
There's theta_1, theta_2.

743
00:36:21,627 --> 00:36:22,710
Each one, I have a choice.

744
00:36:22,710 --> 00:36:23,626
Do I go right or left?

745
00:36:23,626 --> 00:36:27,690

746
00:36:27,690 --> 00:36:30,110
In the end, the sum
must equal zero.

747
00:36:30,110 --> 00:36:33,400
So this problem is
the same problem

748
00:36:33,400 --> 00:36:36,690
really as given a
bunch of numbers,

749
00:36:36,690 --> 00:36:42,300
can I assign signs of plus or
minus so that they add up to 0?

750
00:36:42,300 --> 00:36:45,340
But assigning signs of plus
or minus so they add up to

751
00:36:45,340 --> 00:36:48,980
is the same as saying all the
plus guys equal all the minus

752
00:36:48,980 --> 00:36:50,600
guys.

753
00:36:50,600 --> 00:37:06,170
So really, this problem becomes
assigning pluses and minuses,

754
00:37:06,170 --> 00:37:10,020
so that the sum with
the appropriate pluses

755
00:37:10,020 --> 00:37:12,050
or minuses of
theta_i is equal 0.

756
00:37:12,050 --> 00:37:14,500
That's the Kawasaki version.

757
00:37:14,500 --> 00:37:18,050
But that's the same thing as
saying the sum of the pluses

758
00:37:18,050 --> 00:37:22,190
equals the sum of the minuses.

759
00:37:22,190 --> 00:37:24,500
And if that's the case,
then really you've

760
00:37:24,500 --> 00:37:28,640
partitioned your numbers
into two halves of equal sum.

761
00:37:28,640 --> 00:37:31,820
So this is going to be
possible exactly when there's

762
00:37:31,820 --> 00:37:33,000
a partition.

763
00:37:33,000 --> 00:37:34,680
And so you've
converted Partition

764
00:37:34,680 --> 00:37:37,480
into this problem, which
means this problem is harder.

765
00:37:37,480 --> 00:37:40,030
Because it has other
situations maybe.

766
00:37:40,030 --> 00:37:41,870
But you take any
partition, and are actually

767
00:37:41,870 --> 00:37:43,000
pretty much identical.

768
00:37:43,000 --> 00:37:46,690
But Partition becomes a
special case with this problem.

769
00:37:46,690 --> 00:37:50,070
Therefore, this problem is
harder, and therefore NP-hard.

770
00:37:50,070 --> 00:37:52,280
It's only weakly NP-hard.

771
00:37:52,280 --> 00:37:55,760
But that's a minor detail.

772
00:37:55,760 --> 00:37:57,720
Clear?

773
00:37:57,720 --> 00:37:58,330
All right.

774
00:37:58,330 --> 00:38:03,500
Now we move on to the
more, I don't know,

775
00:38:03,500 --> 00:38:06,080
that's a brand new result,
and a very simple one.

776
00:38:06,080 --> 00:38:09,160

777
00:38:09,160 --> 00:38:13,040
Now we move on to the sort of
more established, well-studied

778
00:38:13,040 --> 00:38:13,540
problems.

779
00:38:13,540 --> 00:38:15,977

780
00:38:15,977 --> 00:38:18,310
The NP-hardness proofs are
quite a bit more complicated.

781
00:38:18,310 --> 00:38:22,160
But they're still, they
all follow the same spirit.

782
00:38:22,160 --> 00:38:24,470
And they're a lot of fun,
because they involve gadgets.

783
00:38:24,470 --> 00:38:26,580
Here there aren't
really any gadgets.

784
00:38:26,580 --> 00:38:29,580
We represented an
integer by an angle.

785
00:38:29,580 --> 00:38:30,410
It's pretty direct.

786
00:38:30,410 --> 00:38:31,951
But in some sense,
that's the gadget.

787
00:38:31,951 --> 00:38:33,390
And we just used n of them.

788
00:38:33,390 --> 00:38:36,240
All of the other proofs are
going to use tons of gadgets.

789
00:38:36,240 --> 00:38:38,570
And they're kind of fun.

790
00:38:38,570 --> 00:38:39,654
I love NP-hard proofs.

791
00:38:39,654 --> 00:38:41,070
They're one of my
favorite things.

792
00:38:41,070 --> 00:38:45,794

793
00:38:45,794 --> 00:38:47,210
All right, one of
the first things

794
00:38:47,210 --> 00:38:50,670
we talked about in this
class was simple folds.

795
00:38:50,670 --> 00:38:52,605
And we showed that in
one dimension, if you

796
00:38:52,605 --> 00:38:54,150
had a one dimensional
piece of paper,

797
00:38:54,150 --> 00:38:55,380
simple folds were universal.

798
00:38:55,380 --> 00:38:58,560
You could make any flat,
foldable crease pattern.

799
00:38:58,560 --> 00:39:01,110
And if you remember,
at the very end,

800
00:39:01,110 --> 00:39:04,450
we talked about
map folding, which

801
00:39:04,450 --> 00:39:07,310
is where you have a bunch
of orthogonal creases

802
00:39:07,310 --> 00:39:13,010
in a rectangular paper, and
maybe also with mountain-valley

803
00:39:13,010 --> 00:39:14,370
assignment.

804
00:39:14,370 --> 00:39:16,070
And we showed that
this problem really

805
00:39:16,070 --> 00:39:19,250
is a bunch of one
dimensional problems.

806
00:39:19,250 --> 00:39:21,720
And so if we wanted to
solve it was simple folds,

807
00:39:21,720 --> 00:39:23,970
where you only fold along
a single line at a time

808
00:39:23,970 --> 00:39:27,630
by 180 degrees, then
really this turned

809
00:39:27,630 --> 00:39:30,179
into a one dimensional
problem in one dimension, then

810
00:39:30,179 --> 00:39:32,220
a one dimensional problem
in the other dimension.

811
00:39:32,220 --> 00:39:34,090
You just kept doing
that until either you

812
00:39:34,090 --> 00:39:36,800
got stuck, in which case the
thing was not flat foldable,

813
00:39:36,800 --> 00:39:38,100
or you flat folded it.

814
00:39:38,100 --> 00:39:41,790
So this is an example where
simple folding is easy.

815
00:39:41,790 --> 00:39:43,700
But in general,
deciding whether you

816
00:39:43,700 --> 00:39:47,540
can fold a crease pattern flat
by simple folds is NP-hard.

817
00:39:47,540 --> 00:39:50,600
So for this special
case, it's easy.

818
00:39:50,600 --> 00:39:56,800
For another situation, which
is when the polygons are not

819
00:39:56,800 --> 00:39:59,351
just rectangles, but are
a little more general,

820
00:39:59,351 --> 00:40:00,350
then it becomes NP-hard.

821
00:40:00,350 --> 00:40:04,070

822
00:40:04,070 --> 00:40:07,011
So in general, the problem
is given a crease pattern,

823
00:40:07,011 --> 00:40:08,760
possibly with mountain
valley assignments,

824
00:40:08,760 --> 00:40:17,790
doesn't really matter, can it
be folded flat by simple folds,

825
00:40:17,790 --> 00:40:19,437
by a sequence of simple folds?

826
00:40:19,437 --> 00:40:21,770
Initially we thought maybe
this problem was polynomially

827
00:40:21,770 --> 00:40:25,110
solvable, because simple
folds are so damn simple.

828
00:40:25,110 --> 00:40:32,770
We were wishful,
but it's not true.

829
00:40:32,770 --> 00:40:34,500
This turns out to be NP-hard.

830
00:40:34,500 --> 00:40:39,370

831
00:40:39,370 --> 00:40:45,320
If we take this situation,
the map situation,

832
00:40:45,320 --> 00:40:52,390
and we add 45-degree
folds, creases, so I just

833
00:40:52,390 --> 00:40:55,090
add some things like that.

834
00:40:55,090 --> 00:40:56,775
It looks kind of crazy.

835
00:40:56,775 --> 00:40:58,890
Got to do some subdivision.

836
00:40:58,890 --> 00:41:00,230
I just add 45-degree folds.

837
00:41:00,230 --> 00:41:01,850
Then this problem
becomes NP-hard.

838
00:41:01,850 --> 00:41:05,170
So with orthogonal creases
in a rectangle, it's easy.

839
00:41:05,170 --> 00:41:07,914
But you had one more
direction, it's hard.

840
00:41:07,914 --> 00:41:09,080
Another version that's hard.

841
00:41:09,080 --> 00:41:12,210
If I keep all the creases
horizontal and vertical

842
00:41:12,210 --> 00:41:19,086
but I make an orthogonal polygon
instead of just a rectangle,

843
00:41:19,086 --> 00:41:20,950
then it's also NP-hard.

844
00:41:20,950 --> 00:41:23,040
I'm going to show this
one because it's easier.

845
00:41:23,040 --> 00:41:25,780
But this actually just converts.

846
00:41:25,780 --> 00:41:27,680
You can set up 45
degree folds so

847
00:41:27,680 --> 00:41:30,240
that you are forced to make a
particular orthogonal polygon

848
00:41:30,240 --> 00:41:31,390
to get started.

849
00:41:31,390 --> 00:41:33,270
And then it's the same proof.

850
00:41:33,270 --> 00:41:35,220
So I think I have
the proof here.

851
00:41:35,220 --> 00:41:38,570

852
00:41:38,570 --> 00:41:42,360
So again, we're going to
reduce from Partition.

853
00:41:42,360 --> 00:41:44,230
So we're given n integers.

854
00:41:44,230 --> 00:41:46,000
We want to know whether
we can divide them

855
00:41:46,000 --> 00:41:48,069
into equal summing halves.

856
00:41:48,069 --> 00:41:49,860
And we're going to
represent those integers

857
00:41:49,860 --> 00:41:52,740
by these lengths.

858
00:41:52,740 --> 00:41:57,880
So here's a_n, then
a_3, and a_2, and a_1.

859
00:41:57,880 --> 00:42:03,827
So the lengths in the top part
of the staircase are integers.

860
00:42:03,827 --> 00:42:05,910
We want to somehow divide
those into equal halves.

861
00:42:05,910 --> 00:42:10,550
And when they have two halves,
and I suppose at their sum

862
00:42:10,550 --> 00:42:13,620
is L, capital L. I can
just add them all up.

863
00:42:13,620 --> 00:42:14,520
I should get 2 L.

864
00:42:14,520 --> 00:42:16,850
I divide by 2, I could get
what the target sum is.

865
00:42:16,850 --> 00:42:19,740
So I know ahead of time without
solving the Partition problem

866
00:42:19,740 --> 00:42:23,500
what L ought to be, and
what twice L ought to be.

867
00:42:23,500 --> 00:42:26,210
And then I build this frame
over on the right whose height

868
00:42:26,210 --> 00:42:31,380
is exactly twice
L. And so there's

869
00:42:31,380 --> 00:42:36,350
these creases in the horizontal
creases down the staircase.

870
00:42:36,350 --> 00:42:38,350
All these creases have
to get folded eventually,

871
00:42:38,350 --> 00:42:40,370
and by simple folds.

872
00:42:40,370 --> 00:42:44,040
And then there's also
these two vertical creases

873
00:42:44,040 --> 00:42:46,250
bounding the frame.

874
00:42:46,250 --> 00:42:49,740
So the idea is, well you make
some of the horizontal creases.

875
00:42:49,740 --> 00:42:51,999
Then you fold one of
those horizontal creases.

876
00:42:51,999 --> 00:42:54,040
And then eventually you
have to fold-- I'm sorry,

877
00:42:54,040 --> 00:42:55,100
one of those vertical creases.

878
00:42:55,100 --> 00:42:57,016
I always get horizontal
and vertical confused,

879
00:42:57,016 --> 00:42:59,600
which causes me great
difficulty when trying to sleep.

880
00:42:59,600 --> 00:43:06,360
But so when I fold the first
vertical crease, whatever's

881
00:43:06,360 --> 00:43:08,050
over here comes over here.

882
00:43:08,050 --> 00:43:11,080
If it hits the frame,
I'm in big trouble.

883
00:43:11,080 --> 00:43:12,720
Because then how
am I going to fold

884
00:43:12,720 --> 00:43:15,570
the other horizontal,
other vertical crease

885
00:43:15,570 --> 00:43:20,390
without colliding
with the frame?

886
00:43:20,390 --> 00:43:23,130
If I want to avoid collision
with the frame by simple folds,

887
00:43:23,130 --> 00:43:24,796
and I fold the vertical
crease, I really

888
00:43:24,796 --> 00:43:26,602
should not be
touching the frame.

889
00:43:26,602 --> 00:43:27,870
So you try to fold through it.

890
00:43:27,870 --> 00:43:30,560
They're both valleys
in this case.

891
00:43:30,560 --> 00:43:33,090
It doesn't matter too much.

892
00:43:33,090 --> 00:43:36,630
So what I really need to do
is fold this thing compactly

893
00:43:36,630 --> 00:43:41,130
like this, so that it just
fits inside the frame.

894
00:43:41,130 --> 00:43:43,110
And the only way to
do that is for each

895
00:43:43,110 --> 00:43:45,550
of those vertical
segments of the staircase

896
00:43:45,550 --> 00:43:48,310
to decide should it go
up, or should it go down?

897
00:43:48,310 --> 00:43:50,030
And you do that in
actually pretty much

898
00:43:50,030 --> 00:43:52,790
the same way this proof works.

899
00:43:52,790 --> 00:43:54,265
For each of these
segments here, we

900
00:43:54,265 --> 00:43:57,450
were deciding should I
keep going straight and go,

901
00:43:57,450 --> 00:43:59,290
or should I turn around?

902
00:43:59,290 --> 00:44:00,690
Over here, it's the same deal.

903
00:44:00,690 --> 00:44:03,840
I either keep going
straight, whichever direction

904
00:44:03,840 --> 00:44:05,590
I was going, up or
down, or I turn around.

905
00:44:05,590 --> 00:44:07,381
But I always have a
choice at every crease.

906
00:44:07,381 --> 00:44:10,190
I'll just fold it or not to make
it go up or down how I want.

907
00:44:10,190 --> 00:44:12,107
The up guys are going
to be one of the halves.

908
00:44:12,107 --> 00:44:14,231
And the down guys are going
to be the other halves.

909
00:44:14,231 --> 00:44:15,880
Here, it's the other
side of the paper,

910
00:44:15,880 --> 00:44:18,420
the dark blue versus
the light blue.

911
00:44:18,420 --> 00:44:23,900
As long as those numbers
add up to exactly L,

912
00:44:23,900 --> 00:44:25,110
I've got this twice.

913
00:44:25,110 --> 00:44:32,980
Then I start here at
the middle of the frame.

914
00:44:32,980 --> 00:44:34,790
If I can get them
to balance out,

915
00:44:34,790 --> 00:44:40,200
I will end over here,
also at the middle.

916
00:44:40,200 --> 00:44:43,330
And then I go up by L.
And then I go down by 2 L.

917
00:44:43,330 --> 00:44:46,340
And that will just
fit inside the frame.

918
00:44:46,340 --> 00:44:49,180
But only if I stay in
the middle will that 2 L

919
00:44:49,180 --> 00:44:50,956
fit inside the frame.

920
00:44:50,956 --> 00:44:53,310
And so the only way
for these two creases

921
00:44:53,310 --> 00:44:56,050
to be foldable and not
collide with the frame

922
00:44:56,050 --> 00:44:59,060
is if I can solve the
Partition problem.

923
00:44:59,060 --> 00:45:01,820
Therefore, so finding
simple fold sequences

924
00:45:01,820 --> 00:45:04,890
is actually way harder than
Partition in some sense.

925
00:45:04,890 --> 00:45:06,830
Because this is just
a very specific kind

926
00:45:06,830 --> 00:45:09,790
of map, specific kind of crease
pattern you might want to fold.

927
00:45:09,790 --> 00:45:13,620
And folding that is
exactly Partition.

928
00:45:13,620 --> 00:45:16,070
So the general simple
foldability problem

929
00:45:16,070 --> 00:45:18,920
is going to be NP-hard,
because it includes Partition

930
00:45:18,920 --> 00:45:21,050
as a special case.

931
00:45:21,050 --> 00:45:21,550
Clear?

932
00:45:21,550 --> 00:45:24,791

933
00:45:24,791 --> 00:45:25,290
Good.

934
00:45:25,290 --> 00:45:27,800

935
00:45:27,800 --> 00:45:32,630
That's our easiest proof
among the next three.

936
00:45:32,630 --> 00:45:35,350
Going to get increasingly
difficult, I guess.

937
00:45:35,350 --> 00:45:37,630
But I'll just getting
increasingly sketchy,

938
00:45:37,630 --> 00:45:39,960
so it will be easy for me.

939
00:45:39,960 --> 00:45:43,710

940
00:45:43,710 --> 00:45:45,460
I mean, the more
complicated a proof gets,

941
00:45:45,460 --> 00:45:49,660
somehow I feel like the
number of interesting details

942
00:45:49,660 --> 00:45:50,947
in a proof remains constant.

943
00:45:50,947 --> 00:45:52,405
If the proof gets
more complicated,

944
00:45:52,405 --> 00:45:55,605
then I throw away more
of the messy details.

945
00:45:55,605 --> 00:46:20,530

946
00:46:20,530 --> 00:46:33,490
All right, the next theorem is
also about flat foldability.

947
00:46:33,490 --> 00:46:39,760
But now I don't just
care about simple folds,

948
00:46:39,760 --> 00:46:43,010
I want to look at
regular origami

949
00:46:43,010 --> 00:46:45,850
folds, which are folded states.

950
00:46:45,850 --> 00:46:50,660
So we talked a couple lectures
ago about local foldability,

951
00:46:50,660 --> 00:46:52,850
which was can we
assign mountains

952
00:46:52,850 --> 00:46:54,570
and valleys to
some crease pattern

953
00:46:54,570 --> 00:46:58,000
so that each vertex, if you
cut it out into a little disk,

954
00:46:58,000 --> 00:46:59,850
would by itself fold flat.

955
00:46:59,850 --> 00:47:04,620
And that was easy, polynomially
solvable, actually linear time.

956
00:47:04,620 --> 00:47:06,560
And that was a result
by Bern and Hayes.

957
00:47:06,560 --> 00:47:08,790
Another result in the same
paper by Bern and Hayes,

958
00:47:08,790 --> 00:47:10,850
which is actually sort
of the bigger result

959
00:47:10,850 --> 00:47:13,422
that everyone knows about,
is that if I give you

960
00:47:13,422 --> 00:47:14,880
an arbitrary crease
pattern, I want

961
00:47:14,880 --> 00:47:19,220
to know just does it fold
flat, that's NP-hard.

962
00:47:19,220 --> 00:47:21,650
They proved actually two
NP-hard hardness results.

963
00:47:21,650 --> 00:47:29,900

964
00:47:29,900 --> 00:47:31,470
So this is way back in '96.

965
00:47:31,470 --> 00:47:34,890
This is one of
the oldest results

966
00:47:34,890 --> 00:47:37,450
in computational origami.

967
00:47:37,450 --> 00:47:41,780

968
00:47:41,780 --> 00:47:43,610
So I give you a crease pattern.

969
00:47:43,610 --> 00:47:46,300
I just want to know, is it
flat foldable in the global,

970
00:47:46,300 --> 00:47:47,390
in the regular sense?

971
00:47:47,390 --> 00:47:51,320

972
00:47:51,320 --> 00:47:54,240
This is strongly NP-hard.

973
00:47:54,240 --> 00:47:58,459

974
00:47:58,459 --> 00:48:00,500
The proof I just gave is
actually weakly NP-hard.

975
00:48:00,500 --> 00:48:03,620
It is not known whether that
problem is strongly or weakly

976
00:48:03,620 --> 00:48:05,895
hard, but at least weakly.

977
00:48:05,895 --> 00:48:21,770

978
00:48:21,770 --> 00:48:26,060
The other thing they
proved is that if you're

979
00:48:26,060 --> 00:48:33,667
given a flat foldable, even I
tell you it's flat foldable,

980
00:48:33,667 --> 00:48:35,750
and I even give you the
mountains and valleys that

981
00:48:35,750 --> 00:48:40,010
make it work, still flat
folding thing is NP-hard.

982
00:48:40,010 --> 00:48:53,106

983
00:48:53,106 --> 00:48:55,480
So if I give you a flat-foldable
mountain-valley pattern,

984
00:48:55,480 --> 00:48:58,760
all that's left is to decide
I can fold each vertex.

985
00:48:58,760 --> 00:49:01,200
And then there's this
issue of layering.

986
00:49:01,200 --> 00:49:03,350
If I have two layers of
paper that are overlapping,

987
00:49:03,350 --> 00:49:04,350
they could be like this.

988
00:49:04,350 --> 00:49:05,800
Or they could be like this.

989
00:49:05,800 --> 00:49:07,810
And if I have, for
example, two crimps,

990
00:49:07,810 --> 00:49:11,360
I could decide
how the layers go.

991
00:49:11,360 --> 00:49:13,380
Figuring out what the
right layer ordering is

992
00:49:13,380 --> 00:49:15,110
is really the heart
of the problem.

993
00:49:15,110 --> 00:49:16,761
This is what makes it NP-hard.

994
00:49:16,761 --> 00:49:19,010
Because we know finding a
mountain-valley assignment--

995
00:49:19,010 --> 00:49:21,090
locally things work-- is easy.

996
00:49:21,090 --> 00:49:24,340
But getting that
layering to work is hard.

997
00:49:24,340 --> 00:49:26,370
That's what all
these proofs say.

998
00:49:26,370 --> 00:49:35,312

999
00:49:35,312 --> 00:49:37,645
So I'm going to talk about
the proof of the first result

1000
00:49:37,645 --> 00:49:39,853
though, because the second
one is pretty complicated.

1001
00:49:39,853 --> 00:49:44,820

1002
00:49:44,820 --> 00:49:47,265
It's the same spirit,
just a lot more details.

1003
00:49:47,265 --> 00:49:53,220

1004
00:49:53,220 --> 00:49:55,580
Again, we're going
to do a reduction.

1005
00:49:55,580 --> 00:49:58,920
And we have these two nice
problems, Partition and SAT.

1006
00:49:58,920 --> 00:50:00,420
I'm not going to
use either of them,

1007
00:50:00,420 --> 00:50:02,340
though in theory
you could use SAT.

1008
00:50:02,340 --> 00:50:05,940
I'm going to reduce from one
of my favorite problems, one

1009
00:50:05,940 --> 00:50:08,740
of my favorite NP-hard
problems, I should say.

1010
00:50:08,740 --> 00:50:09,814
Wait, no.

1011
00:50:09,814 --> 00:50:10,730
That's the next proof.

1012
00:50:10,730 --> 00:50:12,130
This is not my favorite.

1013
00:50:12,130 --> 00:50:13,520
It's a pretty good one, though.

1014
00:50:13,520 --> 00:50:15,850
I do like it.

1015
00:50:15,850 --> 00:50:17,490
Is just a little more technical.

1016
00:50:17,490 --> 00:50:30,730

1017
00:50:30,730 --> 00:50:33,430
All positive, not
all equal 3SAT,

1018
00:50:33,430 --> 00:50:37,060
has anyone heard of
this problem before?

1019
00:50:37,060 --> 00:50:41,006
Nadia's heard of it, because
she TA'd this class before.

1020
00:50:41,006 --> 00:50:41,805
It's no surprise.

1021
00:50:41,805 --> 00:50:43,487
So you've read the book.

1022
00:50:43,487 --> 00:50:45,820
This is, there aren't a lot
of proofs that use this one.

1023
00:50:45,820 --> 00:50:49,160
But not-all-equal 3SAT is
actually fairly common.

1024
00:50:49,160 --> 00:50:51,861
All positive is just makes
a little more convenient.

1025
00:50:51,861 --> 00:50:54,360
I think actually the original
proof didn't use all-positive.

1026
00:50:54,360 --> 00:50:55,530
But our book does.

1027
00:50:55,530 --> 00:50:57,680
Because it simplifies things.

1028
00:50:57,680 --> 00:51:01,407
So let me tell you
what this problem is.

1029
00:51:01,407 --> 00:51:02,490
Most people don't know it.

1030
00:51:02,490 --> 00:51:03,115
So don't worry.

1031
00:51:03,115 --> 00:51:08,330

1032
00:51:08,330 --> 00:51:11,600
You could technically,
it's a version of SAT.

1033
00:51:11,600 --> 00:51:13,290
But instead of giving
a Boolean formula,

1034
00:51:13,290 --> 00:51:15,600
I'm going to think of that
it's really a Boolean formula.

1035
00:51:15,600 --> 00:51:17,766
But I'm going to think of
it in a simpler way, which

1036
00:51:17,766 --> 00:51:21,890
is I give you a bunch of triples
if variables, so like xi,

1037
00:51:21,890 --> 00:51:23,350
xj xk.

1038
00:51:23,350 --> 00:51:28,799
And I want to know is
there a Boolean assignment

1039
00:51:28,799 --> 00:51:29,590
to those variables?

1040
00:51:29,590 --> 00:51:31,455
I want to set each of
them to true or false.

1041
00:51:31,455 --> 00:51:43,230

1042
00:51:43,230 --> 00:51:44,285
Say there's n variables.

1043
00:51:44,285 --> 00:51:47,300

1044
00:51:47,300 --> 00:51:56,650
So that no triple is
all equal, no triple

1045
00:51:56,650 --> 00:52:01,405
is all true or all false.

1046
00:52:01,405 --> 00:52:06,950

1047
00:52:06,950 --> 00:52:10,070
Maybe we could call it
the all state problem.

1048
00:52:10,070 --> 00:52:11,920
I've been watching too many ads.

1049
00:52:11,920 --> 00:52:16,900
All right, so if not-all-equal
3SAT, that's this version.

1050
00:52:16,900 --> 00:52:18,430
Actually, it's
also all-positive,

1051
00:52:18,430 --> 00:52:20,960
meaning I don't have
any nots in here.

1052
00:52:20,960 --> 00:52:22,380
So ignore that.

1053
00:52:22,380 --> 00:52:24,260
Ignore the technical term.

1054
00:52:24,260 --> 00:52:25,720
This is the right definition.

1055
00:52:25,720 --> 00:52:27,796
So I have a bunch of
triples of variables.

1056
00:52:27,796 --> 00:52:30,170
I just don't want them all to
be true or all to be false.

1057
00:52:30,170 --> 00:52:32,586
So two of them could be true
and one false, or two of them

1058
00:52:32,586 --> 00:52:34,330
could be false, and one true.

1059
00:52:34,330 --> 00:52:35,095
That's all.

1060
00:52:35,095 --> 00:52:38,316
It turns out this is
basically equivalent to SAT.

1061
00:52:38,316 --> 00:52:39,940
But the proof of that
is kind of messy.

1062
00:52:39,940 --> 00:52:42,280
So I don't want to do it here.

1063
00:52:42,280 --> 00:52:45,540

1064
00:52:45,540 --> 00:52:47,410
And so that problem is NP-hard.

1065
00:52:47,410 --> 00:52:50,850
Just take that on faith.

1066
00:52:50,850 --> 00:52:55,640
And now I want to show that
global flat foldability

1067
00:52:55,640 --> 00:52:59,310
includes all-positive
not-all-equal 3SAT

1068
00:52:59,310 --> 00:53:00,810
as a special case.

1069
00:53:00,810 --> 00:53:02,550
And therefore,
it's also NP-hard.

1070
00:53:02,550 --> 00:53:11,510

1071
00:53:11,510 --> 00:53:15,555
So I'll give you a preview.

1072
00:53:15,555 --> 00:53:23,990

1073
00:53:23,990 --> 00:53:35,670
Start with a high level, what
we need in terms of gadgets.

1074
00:53:35,670 --> 00:53:44,572

1075
00:53:44,572 --> 00:53:46,030
And then I'll show
you the gadgets,

1076
00:53:46,030 --> 00:53:48,990
and then show you how
they fit together.

1077
00:53:48,990 --> 00:53:51,920
So this is a general
picture, in fact,

1078
00:53:51,920 --> 00:53:54,960
of what a SAT kind of
NP-hardness proof looks like.

1079
00:53:54,960 --> 00:53:59,014
If you haven't done many
of them, now you'll know.

1080
00:53:59,014 --> 00:54:00,430
If you have done
many of them, you

1081
00:54:00,430 --> 00:54:02,240
will recognize
this pattern, which

1082
00:54:02,240 --> 00:54:05,990
is to represent
Boolean-ness, we need

1083
00:54:05,990 --> 00:54:07,790
something that represents
true and false.

1084
00:54:07,790 --> 00:54:09,165
And that's usually
called a wire.

1085
00:54:09,165 --> 00:54:12,709
We think of digital
signals like chips.

1086
00:54:12,709 --> 00:54:15,250
And then we've got to be able
to connect those wires together

1087
00:54:15,250 --> 00:54:16,420
to do interesting things.

1088
00:54:16,420 --> 00:54:18,700
In this case, the interesting
thing we need to do

1089
00:54:18,700 --> 00:54:20,980
is tell if I have
a triple of them,

1090
00:54:20,980 --> 00:54:23,450
are they all true or
all false, and somehow

1091
00:54:23,450 --> 00:54:26,070
force them to not be
all true or all false.

1092
00:54:26,070 --> 00:54:29,380
And in this case, that will
be a not-all-equal clause.

1093
00:54:29,380 --> 00:54:31,510
It'll be a gadget
the folds flat,

1094
00:54:31,510 --> 00:54:34,420
exactly when those wires that
come together, three wires

1095
00:54:34,420 --> 00:54:35,420
come together.

1096
00:54:35,420 --> 00:54:37,580
And if they're all truth,
they won't fold flat.

1097
00:54:37,580 --> 00:54:39,340
If they're all false,
it won't fold flat.

1098
00:54:39,340 --> 00:54:41,760
In all of the cases,
it will fold flat.

1099
00:54:41,760 --> 00:54:43,680
So if we could
build that, that'll

1100
00:54:43,680 --> 00:54:45,930
constrain the variables
that I connect together

1101
00:54:45,930 --> 00:54:47,910
with a not-all-equal clause.

1102
00:54:47,910 --> 00:54:51,980
But how do I actually
move the wires around

1103
00:54:51,980 --> 00:54:54,410
to make them connect
together at these clauses?

1104
00:54:54,410 --> 00:54:56,420
Well, I need something
called a turn gadget.

1105
00:54:56,420 --> 00:54:58,262
If I have a wire
going straight, I'd

1106
00:54:58,262 --> 00:55:00,220
like to be able to turn
it to some other angle.

1107
00:55:00,220 --> 00:55:01,900
I could just sort
of move them around.

1108
00:55:01,900 --> 00:55:03,670
It's harder than it sounds.

1109
00:55:03,670 --> 00:55:06,060
And I'll also need a split.

1110
00:55:06,060 --> 00:55:09,730
Because in this, it's maybe not
obvious from this formulation,

1111
00:55:09,730 --> 00:55:11,450
but I have these n variables.

1112
00:55:11,450 --> 00:55:14,560
I might have many
more than n clauses.

1113
00:55:14,560 --> 00:55:16,240
Each variable, like
x_1, might appear

1114
00:55:16,240 --> 00:55:19,490
in 100 different triples.

1115
00:55:19,490 --> 00:55:22,051
And so I actually
need 100 copies of x_1.

1116
00:55:22,051 --> 00:55:23,550
And that's what a
split gadget does.

1117
00:55:23,550 --> 00:55:24,830
And we're going to
build one gadget called

1118
00:55:24,830 --> 00:55:27,290
a reflector, which actually
does both of those in one

1119
00:55:27,290 --> 00:55:29,120
fell swoop.

1120
00:55:29,120 --> 00:55:31,170
And the last thing we
need is a crossover.

1121
00:55:31,170 --> 00:55:34,280
Because you make all these
connections between variables

1122
00:55:34,280 --> 00:55:36,950
and clauses or triples.

1123
00:55:36,950 --> 00:55:38,729
And they might have
to cross each other.

1124
00:55:38,729 --> 00:55:40,270
And we want them to
cross each other,

1125
00:55:40,270 --> 00:55:42,010
but not affect each other.

1126
00:55:42,010 --> 00:55:44,120
And because we're
in a sheet of paper,

1127
00:55:44,120 --> 00:55:45,341
we've got to deal with that.

1128
00:55:45,341 --> 00:55:47,840
It's going to be these wires
to go right through each other.

1129
00:55:47,840 --> 00:55:49,381
We got to make it
still flat foldable

1130
00:55:49,381 --> 00:55:52,290
without affecting either wire.

1131
00:55:52,290 --> 00:55:54,900
That's all.

1132
00:55:54,900 --> 00:55:57,460
That's pretty standard
for this kind of proof.

1133
00:55:57,460 --> 00:56:00,110
These are the proofs that
I like the most, actually.

1134
00:56:00,110 --> 00:56:00,650
Pretty fun.

1135
00:56:00,650 --> 00:56:03,610
So in our case, a wire is
going to be super easy.

1136
00:56:03,610 --> 00:56:09,580
It's just pleat, so two very
nearby parallel creases.

1137
00:56:09,580 --> 00:56:12,650
And because they're nearby,
I mean, if you look locally,

1138
00:56:12,650 --> 00:56:14,214
it's like a one
dimensional problem.

1139
00:56:14,214 --> 00:56:16,130
They can't both be valley
or both be mountain.

1140
00:56:16,130 --> 00:56:19,270
Because then these
two big panels

1141
00:56:19,270 --> 00:56:21,127
would intersect each other.

1142
00:56:21,127 --> 00:56:23,210
So one of them is valley,
one of them is mountain.

1143
00:56:23,210 --> 00:56:24,617
There's exactly two choices.

1144
00:56:24,617 --> 00:56:26,450
I'm going to always
have an arrow on my wire

1145
00:56:26,450 --> 00:56:27,990
so I have a sense
of orientation,

1146
00:56:27,990 --> 00:56:29,270
which way the signal is going.

1147
00:56:29,270 --> 00:56:31,730
And once I have an
orientation, the left side,

1148
00:56:31,730 --> 00:56:34,020
if the left side is
valley, that's true.

1149
00:56:34,020 --> 00:56:36,740
If the left side is
mountain, that's false.

1150
00:56:36,740 --> 00:56:38,704
That's just I'm going
to decide it that way.

1151
00:56:38,704 --> 00:56:40,870
It doesn't actually matter,
because in this problem,

1152
00:56:40,870 --> 00:56:42,300
true and false are symmetric.

1153
00:56:42,300 --> 00:56:46,880
But I just need to be
consistent about which is which.

1154
00:56:46,880 --> 00:56:48,562
OK, so that was the wire gadget.

1155
00:56:48,562 --> 00:56:50,270
The next one is the
not-all-equal gadget.

1156
00:56:50,270 --> 00:56:54,150
And I'm guessing this is
where Bern and Hayes started.

1157
00:56:54,150 --> 00:56:56,670
Because it's sort of
the heart of the proof.

1158
00:56:56,670 --> 00:56:59,170
Then there's all these details
to connect up with the wires,

1159
00:56:59,170 --> 00:57:00,336
and split them, and whatnot.

1160
00:57:00,336 --> 00:57:04,789
But this is something
called a triangular twist.

1161
00:57:04,789 --> 00:57:06,080
You may have folded one before.

1162
00:57:06,080 --> 00:57:07,604
It's kind of classic.

1163
00:57:07,604 --> 00:57:09,270
So the crease pattern's
in the top left.

1164
00:57:09,270 --> 00:57:11,395
And the idea is I have
three wires coming together.

1165
00:57:11,395 --> 00:57:15,100
I want this thing to fold flat
if and only if the wires are

1166
00:57:15,100 --> 00:57:17,580
not all the same.

1167
00:57:17,580 --> 00:57:20,770
And I've drawn here sort of
three of the possible patterns

1168
00:57:20,770 --> 00:57:21,420
you could have.

1169
00:57:21,420 --> 00:57:23,030
Here I have one
truth and two false.

1170
00:57:23,030 --> 00:57:24,650
That folds flat.

1171
00:57:24,650 --> 00:57:27,640
Here I have three false.

1172
00:57:27,640 --> 00:57:29,830
And here I have two
true and one false.

1173
00:57:29,830 --> 00:57:31,740
This also folds flat.

1174
00:57:31,740 --> 00:57:37,102
In all cases, this is what
the folded state looks like.

1175
00:57:37,102 --> 00:57:38,310
I maybe never mentioned this.

1176
00:57:38,310 --> 00:57:40,070
But this is an
important concept.

1177
00:57:40,070 --> 00:57:44,790
If you take a crease pattern and
you say I want to fold it flat,

1178
00:57:44,790 --> 00:57:47,210
you can tell where
all the stuff is

1179
00:57:47,210 --> 00:57:49,400
going to go in
terms of geometry.

1180
00:57:49,400 --> 00:57:51,230
What you can't tell
is the layer ordering.

1181
00:57:51,230 --> 00:57:52,690
That depends on the
mountain-valley assignment.

1182
00:57:52,690 --> 00:57:55,170
That depends on how you
decide the layers to stack.

1183
00:57:55,170 --> 00:57:58,490
But you can tell already where
everything goes in the plane.

1184
00:57:58,490 --> 00:58:02,570
Because you pick, let's see,
did anything stay fixed here.

1185
00:58:02,570 --> 00:58:04,350
Yeah, the triangle stayed fix.

1186
00:58:04,350 --> 00:58:06,600
So you pick some face to
stay fixed, like that center

1187
00:58:06,600 --> 00:58:07,162
triangle.

1188
00:58:07,162 --> 00:58:07,870
You put it there.

1189
00:58:07,870 --> 00:58:09,400
And then you say, OK.

1190
00:58:09,400 --> 00:58:10,570
Well, where is this flap?

1191
00:58:10,570 --> 00:58:13,420
Where is this face of the
crease pattern going to go?

1192
00:58:13,420 --> 00:58:17,120
Well, it gets reflected
through that horizontal line.

1193
00:58:17,120 --> 00:58:18,916
So it goes here.

1194
00:58:18,916 --> 00:58:21,040
And you can just keep
playing this reflection game.

1195
00:58:21,040 --> 00:58:23,580
Because you know every
crease geometrically,

1196
00:58:23,580 --> 00:58:24,330
it's a reflection.

1197
00:58:24,330 --> 00:58:26,340
It could be a reflection
this way or this way.

1198
00:58:26,340 --> 00:58:28,400
But it just, as soon
as you cross a crease,

1199
00:58:28,400 --> 00:58:30,820
you end up reflecting
your material.

1200
00:58:30,820 --> 00:58:33,520
And so you can draw this
picture without knowing anything

1201
00:58:33,520 --> 00:58:34,472
about how it's folded.

1202
00:58:34,472 --> 00:58:36,930
Just if there's a flat folding,
it's got to look like this.

1203
00:58:36,930 --> 00:58:38,380
And the annoying
thing about this

1204
00:58:38,380 --> 00:58:43,190
set up, because that angle
up there is 35 degrees,

1205
00:58:43,190 --> 00:58:47,490
these guys are going to
overlap in this common center.

1206
00:58:47,490 --> 00:58:51,010
And in this situation where
it's all false or all true,

1207
00:58:51,010 --> 00:58:53,581
you get an intersection there.

1208
00:58:53,581 --> 00:58:54,830
It's a little tricky to prove.

1209
00:58:54,830 --> 00:58:56,455
And you've just got
to fiddle with one.

1210
00:58:56,455 --> 00:59:00,900
I should have brought
one, but that is true.

1211
00:59:00,900 --> 00:59:03,150
And so in the all false and
symmetrically the all true

1212
00:59:03,150 --> 00:59:05,020
case, this thing
does not fold flat.

1213
00:59:05,020 --> 00:59:06,930
In all the other
situations, it folds fine.

1214
00:59:06,930 --> 00:59:10,140
Because the layers
get out of the way.

1215
00:59:10,140 --> 00:59:13,360
OK, also over here, and there's
a bunch of these in the book,

1216
00:59:13,360 --> 00:59:15,710
are little analyses of
which of the creases

1217
00:59:15,710 --> 00:59:17,965
have to have the same
mountain-valley assignment

1218
00:59:17,965 --> 00:59:19,710
and which have to
have different.

1219
00:59:19,710 --> 00:59:22,280
That's actually how
these patterns are drawn.

1220
00:59:22,280 --> 00:59:25,840
This is from our old local
analysis of a single vertex

1221
00:59:25,840 --> 00:59:27,020
crease pattern, right.

1222
00:59:27,020 --> 00:59:28,899
You've got these four creases.

1223
00:59:28,899 --> 00:59:29,440
Check it out.

1224
00:59:29,440 --> 00:59:32,710
The only one that could
be crimped is this one.

1225
00:59:32,710 --> 00:59:34,210
Because it's globally smallest.

1226
00:59:34,210 --> 00:59:39,590
All the other guys have a bigger
neighbor or are in trouble.

1227
00:59:39,590 --> 00:59:40,840
So this guy has to be crimped.

1228
00:59:40,840 --> 00:59:43,366
So these two are not equal.

1229
00:59:43,366 --> 00:59:44,990
And therefore, these
two must be equal.

1230
00:59:44,990 --> 00:59:46,879
And that's symmetrical
all the way around.

1231
00:59:46,879 --> 00:59:48,420
So in fact, you know
that this crease

1232
00:59:48,420 --> 00:59:50,514
is different from this
one, is equal to this one.

1233
00:59:50,514 --> 00:59:52,430
You already knew that
these two are different.

1234
00:59:52,430 --> 00:59:54,530
So that's OK.

1235
00:59:54,530 --> 00:59:57,260
So you can figure out
these crease patterns.

1236
00:59:57,260 --> 01:00:00,519
There's a little bit of flexi--
once you have the mountains

1237
01:00:00,519 --> 01:00:03,060
and valleys coming in, you know
how the mountains and valleys

1238
01:00:03,060 --> 01:00:04,340
have to be in the center.

1239
01:00:04,340 --> 01:00:05,599
Just makes life easier.

1240
01:00:05,599 --> 01:00:07,390
There's only one mountain
valley assignment

1241
01:00:07,390 --> 01:00:08,650
you need to consider.

1242
01:00:08,650 --> 01:00:12,220
And the symmetric one
turns out to be bad.

1243
01:00:12,220 --> 01:00:14,080
So that's two gadgets.

1244
01:00:14,080 --> 01:00:17,020
We got the wire, the
not-all-equal clause.

1245
01:00:17,020 --> 01:00:19,912
Of course, if we're
lucky, all the wires

1246
01:00:19,912 --> 01:00:21,370
will just meet at
the right points.

1247
01:00:21,370 --> 01:00:22,710
But I'm going to need
many copies of them.

1248
01:00:22,710 --> 01:00:24,390
I've got to move
them around to reach

1249
01:00:24,390 --> 01:00:28,550
all the different clauses,
all the different triples.

1250
01:00:28,550 --> 01:00:30,265
So next up is reflector.

1251
01:00:30,265 --> 01:00:37,060

1252
01:00:37,060 --> 01:00:39,820
This is actually in
some sense really easy.

1253
01:00:39,820 --> 01:00:43,792
So we have, here's our input.

1254
01:00:43,792 --> 01:00:45,500
What the reflector is
going to do is it's

1255
01:00:45,500 --> 01:00:49,850
going to make two copies, one
down here which is negated,

1256
01:00:49,850 --> 01:00:53,690
and one up here, which
is the same value.

1257
01:00:53,690 --> 01:00:55,430
And it also effectively
turns the signal

1258
01:00:55,430 --> 01:00:57,900
two different directions.

1259
01:00:57,900 --> 01:01:01,600
So to see why it works
is actually pretty easy.

1260
01:01:01,600 --> 01:01:03,900
It's just a local
analysis again.

1261
01:01:03,900 --> 01:01:05,210
You look at this vertex.

1262
01:01:05,210 --> 01:01:07,770
This is the only increase
they could be crimped.

1263
01:01:07,770 --> 01:01:11,620
So we know that these two
guys have opposite assignment.

1264
01:01:11,620 --> 01:01:15,647
Therefore, these two wires
will have opposite value.

1265
01:01:15,647 --> 01:01:17,230
And actually, they
have the same value

1266
01:01:17,230 --> 01:01:18,980
if they're pointing
in the same direction.

1267
01:01:18,980 --> 01:01:21,180
But they'll have
opposite value because I

1268
01:01:21,180 --> 01:01:24,186
decided this one's
pointing down.

1269
01:01:24,186 --> 01:01:26,560
So if this one's a mountain,
this one has to be a valley.

1270
01:01:26,560 --> 01:01:29,150
And so if this is true because
it's valley on the left,

1271
01:01:29,150 --> 01:01:32,786
this one's false because
it's mountain on the left.

1272
01:01:32,786 --> 01:01:34,530
OK, and then you can
do the same thing.

1273
01:01:34,530 --> 01:01:37,020
Then you also know these
two guys are equal.

1274
01:01:37,020 --> 01:01:40,150
And because again, this is
the only crimpable pair here,

1275
01:01:40,150 --> 01:01:42,230
these two creases are not equal.

1276
01:01:42,230 --> 01:01:43,982
And so you know these
two guys are equal

1277
01:01:43,982 --> 01:01:45,190
and these two guys are equal.

1278
01:01:45,190 --> 01:01:50,630
And so you know that this
valley is propagated up there.

1279
01:01:50,630 --> 01:01:52,986
And therefore, these two
wires have the same value.

1280
01:01:52,986 --> 01:01:54,110
So you've split the signal.

1281
01:01:54,110 --> 01:01:57,290
You've made a positive
copy and a negated copy.

1282
01:01:57,290 --> 01:01:59,240
And if you just do
this again, you'll

1283
01:01:59,240 --> 01:02:04,490
get-- this will make
another negated copy

1284
01:02:04,490 --> 01:02:06,792
and a positive copy.

1285
01:02:06,792 --> 01:02:08,750
So I get two positive
copies and a negated one.

1286
01:02:08,750 --> 01:02:10,375
You can just keep
doing this and you'll

1287
01:02:10,375 --> 01:02:12,584
get tons of positive copies,
tons of negative copies.

1288
01:02:12,584 --> 01:02:14,541
So it doesn't even matter
if it's all-positive.

1289
01:02:14,541 --> 01:02:16,000
But if you take
all-positive ones.

1290
01:02:16,000 --> 01:02:17,660
Let the others go
off to infinity.

1291
01:02:17,660 --> 01:02:20,930
And now you want to
move around so that they

1292
01:02:20,930 --> 01:02:22,807
hit those not-all-equal clauses.

1293
01:02:22,807 --> 01:02:23,890
How do I move them around?

1294
01:02:23,890 --> 01:02:25,540
I just use more reflectors.

1295
01:02:25,540 --> 01:02:27,980
If I come in at some
angle, I can now

1296
01:02:27,980 --> 01:02:29,970
turn by however much that is.

1297
01:02:29,970 --> 01:02:32,156
Or I can turn by
however much that is.

1298
01:02:32,156 --> 01:02:34,530
I'm not going to try to figure
out what those angles are.

1299
01:02:34,530 --> 01:02:39,416
But it turns out, this is
enough to make everything work.

1300
01:02:39,416 --> 01:02:41,790
The last thing you need are
a bunch of crossover gadgets.

1301
01:02:41,790 --> 01:02:42,623
This is one of them.

1302
01:02:42,623 --> 01:02:43,975
There's a second one.

1303
01:02:43,975 --> 01:02:45,600
I'll just wave my
hands and say, if you

1304
01:02:45,600 --> 01:02:48,000
take two pleats in
the obvious way,

1305
01:02:48,000 --> 01:02:50,090
they really don't
care about each other.

1306
01:02:50,090 --> 01:02:52,005
Because the way to
fold this locally,

1307
01:02:52,005 --> 01:02:54,710
is to fold this diagonal
pleat and then fold

1308
01:02:54,710 --> 01:02:55,810
the vertical pleat.

1309
01:02:55,810 --> 01:02:58,376
And it will work whether
one pleat is true or false.

1310
01:02:58,376 --> 01:03:01,000
It doesn't matter which side is
valley, which side is mountain.

1311
01:03:01,000 --> 01:03:02,480
It always works.

1312
01:03:02,480 --> 01:03:06,070
So crossovers aren't
actually that big a deal.

1313
01:03:06,070 --> 01:03:08,130
Once you have that,
you take those gadgets.

1314
01:03:08,130 --> 01:03:10,060
And you put them together
into a monstrosity

1315
01:03:10,060 --> 01:03:13,740
of a crease pattern, which
looks something like this.

1316
01:03:13,740 --> 01:03:17,030
And this took forever
to draw, I remember.

1317
01:03:17,030 --> 01:03:20,160
So we have on the left
side our variables.

1318
01:03:20,160 --> 01:03:21,180
These are just wires.

1319
01:03:21,180 --> 01:03:22,460
They're pleats.

1320
01:03:22,460 --> 01:03:25,580
And each one could be
folded true or false,

1321
01:03:25,580 --> 01:03:28,120
left over right or
right over left.

1322
01:03:28,120 --> 01:03:30,040
And then I do a whole
bunch of reflectors,

1323
01:03:30,040 --> 01:03:32,310
just reflect, reflect,
reflect, reflect, reflect,

1324
01:03:32,310 --> 01:03:35,440
just to make a whole
bunch of copies.

1325
01:03:35,440 --> 01:03:43,610
And then at the top there, way
at that little yellow triangle,

1326
01:03:43,610 --> 01:03:45,240
is a not-all-equal clause.

1327
01:03:45,240 --> 01:03:49,370
And is a not-all-equal
clause between x_3,

1328
01:03:49,370 --> 01:03:51,070
where we make a copy.

1329
01:03:51,070 --> 01:03:52,580
Wow, this is crazy.

1330
01:03:52,580 --> 01:03:54,810
I end up making a copy,
negate it downwards,

1331
01:03:54,810 --> 01:03:56,230
and I flip it around.

1332
01:03:56,230 --> 01:03:58,140
And it goes up straight.

1333
01:03:58,140 --> 01:04:00,900
And then I turn it at an angle
to hit the triangle dead on,

1334
01:04:00,900 --> 01:04:02,950
the way it's supposed to.

1335
01:04:02,950 --> 01:04:06,390
Then I also take x_1
up the top, just get

1336
01:04:06,390 --> 01:04:08,090
a copy straight
off the top there.

1337
01:04:08,090 --> 01:04:10,299
And x_2, I take a copy here.

1338
01:04:10,299 --> 01:04:12,590
For some reason I feel like
negating it, and turning it

1339
01:04:12,590 --> 01:04:14,890
around, and spitting
it up there.

1340
01:04:14,890 --> 01:04:16,200
And then I turn it back down.

1341
01:04:16,200 --> 01:04:18,490
It hits the yellow triangle
at just the right angle.

1342
01:04:18,490 --> 01:04:20,573
And therefore, if this
thing's going to fold flat,

1343
01:04:20,573 --> 01:04:23,000
it must be that x_1, x_2,
and x_3 are not all equal.

1344
01:04:23,000 --> 01:04:25,980
And you just keep doing
that, one for every triple.

1345
01:04:25,980 --> 01:04:30,880
Remember, we're given as input
one of these not-all-equal SAT

1346
01:04:30,880 --> 01:04:31,380
problems.

1347
01:04:31,380 --> 01:04:32,770
I give you a bunch of triples.

1348
01:04:32,770 --> 01:04:37,040
I just put the wires together
according to those triples.

1349
01:04:37,040 --> 01:04:38,820
This thing we flat
foldable if and only

1350
01:04:38,820 --> 01:04:42,790
if this formula is satisfiable.

1351
01:04:42,790 --> 01:04:46,040
You can set the pleats so that
the desired triples are not

1352
01:04:46,040 --> 01:04:47,010
equal.

1353
01:04:47,010 --> 01:04:48,760
So that's pretty crazy.

1354
01:04:48,760 --> 01:04:51,360
This is in some sense
one of the hardest proofs

1355
01:04:51,360 --> 01:04:54,210
that we will see.

1356
01:04:54,210 --> 01:04:56,215
But in the end,
you get NP-hardness

1357
01:04:56,215 --> 01:04:59,105
of flat foldability.

1358
01:04:59,105 --> 01:04:59,605
Questions?

1359
01:04:59,605 --> 01:05:02,360

1360
01:05:02,360 --> 01:05:05,385
OK, I want to do one
more proof sketch.

1361
01:05:05,385 --> 01:05:40,390

1362
01:05:40,390 --> 01:05:43,040
This is yet another
paper that was

1363
01:05:43,040 --> 01:05:45,300
at this year's Origami in
Science Math and Education

1364
01:05:45,300 --> 01:05:46,380
conference.

1365
01:05:46,380 --> 01:05:49,310
This is, it's fun
to teach this class.

1366
01:05:49,310 --> 01:05:52,720
Because it changes so much
over a period of three years.

1367
01:05:52,720 --> 01:05:53,580
Lots of new results.

1368
01:05:53,580 --> 01:05:54,960
This is a result
with a guy named

1369
01:05:54,960 --> 01:05:56,880
Sandor Fekete from Germany.

1370
01:05:56,880 --> 01:06:03,580
He does a lot of optimization,
and Robert Lang, and myself.

1371
01:06:03,580 --> 01:06:08,230
So disk packing is something
we talked about last class

1372
01:06:08,230 --> 01:06:11,050
in the context of the tree
method of origami design.

1373
01:06:11,050 --> 01:06:13,860
We said, in particular we were
thinking of this situation

1374
01:06:13,860 --> 01:06:16,790
where we wanted to make them
a Margulis napkin counter

1375
01:06:16,790 --> 01:06:18,690
example.

1376
01:06:18,690 --> 01:06:19,890
So this was equivalent.

1377
01:06:19,890 --> 01:06:24,150
If we wanted to build this
uniaxial base and sides,

1378
01:06:24,150 --> 01:06:30,710
was the same thing as packing
n disks into a square.

1379
01:06:30,710 --> 01:06:34,330
That's what the
tree method shows.

1380
01:06:34,330 --> 01:06:36,930
So in some sense, I'm
talking about this problem.

1381
01:06:36,930 --> 01:06:38,930
But equivalently, I'm
talking about this problem

1382
01:06:38,930 --> 01:06:40,940
of packing disks into a square.

1383
01:06:40,940 --> 01:06:43,750
Now if I give you n unit
disks all the same size,

1384
01:06:43,750 --> 01:06:49,210
I want to pack them in a square,
that problem cannot be NP-hard.

1385
01:06:49,210 --> 01:06:51,300
That's annoying.

1386
01:06:51,300 --> 01:06:53,020
But the input is only n.

1387
01:06:53,020 --> 01:06:54,420
It's not very interesting.

1388
01:06:54,420 --> 01:06:59,800
So to make it harder, be able
to show that this problem is

1389
01:06:59,800 --> 01:07:01,700
computationally
intractable, I'm going

1390
01:07:01,700 --> 01:07:03,870
to consider
generalization, which

1391
01:07:03,870 --> 01:07:06,680
is I still have this
kind of star tree,

1392
01:07:06,680 --> 01:07:08,780
still a very simple
kind of uniaxial base I

1393
01:07:08,780 --> 01:07:10,180
might want to build.

1394
01:07:10,180 --> 01:07:13,110
But now all the limbs
are different lengths.

1395
01:07:13,110 --> 01:07:18,010
So what that corresponds to is
I have disks of various sizes.

1396
01:07:18,010 --> 01:07:21,810

1397
01:07:21,810 --> 01:07:23,502
It's kind of fun.

1398
01:07:23,502 --> 01:07:24,365
It's like bubbles.

1399
01:07:24,365 --> 01:07:26,946

1400
01:07:26,946 --> 01:07:27,820
They all have to fit.

1401
01:07:27,820 --> 01:07:29,250
They can't overlap each other.

1402
01:07:29,250 --> 01:07:32,340
All of the centers of the
disks are inside the square.

1403
01:07:32,340 --> 01:07:34,930

1404
01:07:34,930 --> 01:07:37,830
And I want to know,
can I-- how big

1405
01:07:37,830 --> 01:07:39,485
a square do I need to pack them?

1406
01:07:39,485 --> 01:07:44,000
OK, I'm going to formulate it as
a decision question, yes or no.

1407
01:07:44,000 --> 01:07:49,860
Can you place n given disks,
I give you the sizes of them.

1408
01:07:49,860 --> 01:07:53,724

1409
01:07:53,724 --> 01:07:55,140
I want them to be
non-overlapping.

1410
01:07:55,140 --> 01:07:58,600

1411
01:07:58,600 --> 01:08:01,240
They can touch on the
boundary but the interiors

1412
01:08:01,240 --> 01:08:03,100
can't overlap.

1413
01:08:03,100 --> 01:08:10,220
And I need the centers
to lie in a given square.

1414
01:08:10,220 --> 01:08:12,510
So I want to know, can I
make this uniaxial base

1415
01:08:12,510 --> 01:08:14,780
from this square paper?

1416
01:08:14,780 --> 01:08:18,060
And I claim that is NP-hard.

1417
01:08:18,060 --> 01:08:21,080
So good luck solving
it perfectly.

1418
01:08:21,080 --> 01:08:22,760
And what tree maker
does is it solves

1419
01:08:22,760 --> 01:08:25,240
it approximately
with a heuristic.

1420
01:08:25,240 --> 01:08:32,125

1421
01:08:32,125 --> 01:08:34,000
For those who know
approximation algorithims,

1422
01:08:34,000 --> 01:08:37,800
this is a problem you can find
a constant factor approximation.

1423
01:08:37,800 --> 01:08:39,490
There's one in the same paper.

1424
01:08:39,490 --> 01:08:41,229
But it's still not,
still unresolved

1425
01:08:41,229 --> 01:08:43,910
how close to
optimal you can get.

1426
01:08:43,910 --> 01:08:46,646

1427
01:08:46,646 --> 01:08:48,479
But I want to focus
here on the NP-hardness.

1428
01:08:48,479 --> 01:08:53,850

1429
01:08:53,850 --> 01:08:57,970
So I should say this
problem is NP-hard.

1430
01:08:57,970 --> 01:09:03,260

1431
01:09:03,260 --> 01:09:04,479
So we're going to prove that.

1432
01:09:04,479 --> 01:09:07,779

1433
01:09:07,779 --> 01:09:12,609
And now I get to reduce
for my favorite problem,

1434
01:09:12,609 --> 01:09:14,890
favorite NP-hard.

1435
01:09:14,890 --> 01:09:18,910
It's my favorite partly
because not many people know it

1436
01:09:18,910 --> 01:09:21,779
unless you've done NP-hardness
proofs with me before.

1437
01:09:21,779 --> 01:09:25,100
And it's very powerful.

1438
01:09:25,100 --> 01:09:27,340
Whenever you have a problem
that involves numbers,

1439
01:09:27,340 --> 01:09:28,756
and this problem
involves numbers.

1440
01:09:28,756 --> 01:09:30,899
It's the radii of the disk's.

1441
01:09:30,899 --> 01:09:34,000
3-Partition is the
problem you should know.

1442
01:09:34,000 --> 01:09:35,680
Partition is all right.

1443
01:09:35,680 --> 01:09:37,640
The 3-Partition
is like 50% better.

1444
01:09:37,640 --> 01:09:41,200

1445
01:09:41,200 --> 01:09:44,420
Because Partition is like you've
partitioned it to two parts.

1446
01:09:44,420 --> 01:09:46,080
So it's like 2-Partition.

1447
01:09:46,080 --> 01:09:47,624
3-Partition, you partition into?

1448
01:09:47,624 --> 01:09:51,280

1449
01:09:51,280 --> 01:09:53,350
Does not one have
the right answer?

1450
01:09:53,350 --> 01:09:55,220
I hear three parts
and five parts.

1451
01:09:55,220 --> 01:09:56,160
Any other guesses?

1452
01:09:56,160 --> 01:09:57,160
AUDIENCE: Seven

1453
01:09:57,160 --> 01:09:59,330
PROFESSOR: Seven.

1454
01:09:59,330 --> 01:10:01,550
Keep going.

1455
01:10:01,550 --> 01:10:04,130
n over three parts
is the answer.

1456
01:10:04,130 --> 01:10:08,041
So it's not so obvious.

1457
01:10:08,041 --> 01:10:09,915
Maybe it should be called
n over 3 Partition.

1458
01:10:09,915 --> 01:10:16,384

1459
01:10:16,384 --> 01:10:18,300
So instead of the number
of parts being three,

1460
01:10:18,300 --> 01:10:21,345
the size of each part is three.

1461
01:10:21,345 --> 01:10:23,220
So n should be divisible by 3.

1462
01:10:23,220 --> 01:10:26,497

1463
01:10:26,497 --> 01:10:28,080
So I'm going to partition
it into n over 3

1464
01:10:28,080 --> 01:10:30,800
triples of numbers
of equal sum.

1465
01:10:30,800 --> 01:10:39,000

1466
01:10:39,000 --> 01:10:43,480
This problem is cool for
this technical reason

1467
01:10:43,480 --> 01:10:45,230
that it is strongly NP-hard.

1468
01:10:45,230 --> 01:10:47,870

1469
01:10:47,870 --> 01:10:54,220
So even when the numbers are
really small, like about n,

1470
01:10:54,220 --> 01:10:55,760
this problem is NP-hard.

1471
01:10:55,760 --> 01:10:58,600
With Partition, the numbers
had to be exponential and n

1472
01:10:58,600 --> 01:10:59,920
for the problem to be hard.

1473
01:10:59,920 --> 01:11:01,690
And that's kind of
artificial here.

1474
01:11:01,690 --> 01:11:04,890
So this is actually
strongly NP-hard.

1475
01:11:04,890 --> 01:11:06,490
So this problem
is hard even when

1476
01:11:06,490 --> 01:11:08,970
the disk sizes are
not that different.

1477
01:11:08,970 --> 01:11:11,620
There's like a range between
one and n, let's say.

1478
01:11:11,620 --> 01:11:14,190
If I reduce from Partition,
I'd need some disks

1479
01:11:14,190 --> 01:11:17,140
to be microscopic and
some to be ginormous,

1480
01:11:17,140 --> 01:11:19,454
exponential difference.

1481
01:11:19,454 --> 01:11:21,120
I'm going to reduce
from 3-Partition

1482
01:11:21,120 --> 01:11:22,580
because I get a better result.

1483
01:11:22,580 --> 01:11:25,080
I get a stronger result the
says even when the disks are not

1484
01:11:25,080 --> 01:11:27,690
so different in size,
this problem is NP-hard.

1485
01:11:27,690 --> 01:11:31,360

1486
01:11:31,360 --> 01:11:42,000
That's my problem that
I'm gonna start from.

1487
01:11:42,000 --> 01:11:44,555
So I give you n integers.

1488
01:11:44,555 --> 01:11:52,930
I want to somehow triple
them up using a disk packing.

1489
01:11:52,930 --> 01:11:54,880
So somehow solving a
disk packing problem

1490
01:11:54,880 --> 01:11:58,220
is going to solve this
3-Partition problem.

1491
01:11:58,220 --> 01:11:59,230
And it's kind of crazy.

1492
01:11:59,230 --> 01:12:03,100

1493
01:12:03,100 --> 01:12:04,830
I'll give you the
high-level picture.

1494
01:12:04,830 --> 01:12:15,527

1495
01:12:15,527 --> 01:12:20,255
It's n over three
identical pockets.

1496
01:12:20,255 --> 01:12:35,750

1497
01:12:35,750 --> 01:12:40,140
So in this case, there
is kind of like the proof

1498
01:12:40,140 --> 01:12:45,064
where we had the simple folds
and we a frame and some stuff.

1499
01:12:45,064 --> 01:12:46,980
We're going to have some
infrastructure, which

1500
01:12:46,980 --> 01:12:48,104
in that case was the frame.

1501
01:12:48,104 --> 01:12:50,570
That was sort of a basic
thing that always exists.

1502
01:12:50,570 --> 01:12:53,028
In this case, we're going to
have some infrastructure which

1503
01:12:53,028 --> 01:12:55,210
is a whole bunch of disks
that just sort of set,

1504
01:12:55,210 --> 01:12:58,070
instead of having this very
open problem, open playing

1505
01:12:58,070 --> 01:13:01,350
field with a square, and like
you could put disks anywhere,

1506
01:13:01,350 --> 01:13:03,390
I want to partition
my square into lots

1507
01:13:03,390 --> 01:13:07,400
of little pockets, all the
same size, all the same shape.

1508
01:13:07,400 --> 01:13:12,952
And all other pockets are
going to be much smaller.

1509
01:13:12,952 --> 01:13:14,410
So it's a little
hard to draw this.

1510
01:13:14,410 --> 01:13:16,159
Because while I said
that the disks aren't

1511
01:13:16,159 --> 01:13:18,390
that different size,
they're only a factor of n

1512
01:13:18,390 --> 01:13:22,030
different in size, if you
try to draw these pictures,

1513
01:13:22,030 --> 01:13:23,900
it gets tiny very quickly.

1514
01:13:23,900 --> 01:13:25,960
So here's the high
level picture.

1515
01:13:25,960 --> 01:13:28,160
You have a square.

1516
01:13:28,160 --> 01:13:31,360
And I'm going to put
down these disks.

1517
01:13:31,360 --> 01:13:39,640
There's 20 disks here, I
think, 4 times 4 is 16 plus 5.

1518
01:13:39,640 --> 01:13:41,330
I'm sorry, 21.

1519
01:13:41,330 --> 01:13:45,017
So these 21 disks, they
have a unique package,

1520
01:13:45,017 --> 01:13:45,850
this one right here.

1521
01:13:45,850 --> 01:13:47,950
You can see that
because these four disks

1522
01:13:47,950 --> 01:13:51,160
have to be in the corners,
can't fit one in the center

1523
01:13:51,160 --> 01:13:52,570
and have room for the others.

1524
01:13:52,570 --> 01:13:54,690
Then this guy has
to go right there.

1525
01:13:54,690 --> 01:13:57,939
And then these four disks are
unique if you set it up right.

1526
01:13:57,939 --> 01:13:59,480
It's a little bit,
it's hard to draw.

1527
01:13:59,480 --> 01:14:04,190
But these are little bit
wedged over to the right.

1528
01:14:04,190 --> 01:14:05,380
So you set up these disks.

1529
01:14:05,380 --> 01:14:06,400
That's infrastructure.

1530
01:14:06,400 --> 01:14:08,220
It's the only way to put them.

1531
01:14:08,220 --> 01:14:10,440
And then there's these
little pockets here.

1532
01:14:10,440 --> 01:14:11,580
They're nice.

1533
01:14:11,580 --> 01:14:12,900
They're symmetric.

1534
01:14:12,900 --> 01:14:15,300
They're like a triangle,
an equilateral triangle

1535
01:14:15,300 --> 01:14:17,340
so to speak, except
they have curved edges.

1536
01:14:17,340 --> 01:14:19,140
They're all the same size.

1537
01:14:19,140 --> 01:14:20,900
That gives me four pockets.

1538
01:14:20,900 --> 01:14:22,760
But I want n over 3 pockets.

1539
01:14:22,760 --> 01:14:24,810
So I'm going to need a lot more.

1540
01:14:24,810 --> 01:14:26,570
So I take each of these pockets.

1541
01:14:26,570 --> 01:14:29,560
That's these three disks.

1542
01:14:29,560 --> 01:14:32,060
And this is the triangular
pocket in the center.

1543
01:14:32,060 --> 01:14:36,500
And I put down these 17 disks.

1544
01:14:36,500 --> 01:14:38,010
It's almost the same.

1545
01:14:38,010 --> 01:14:39,890
And I can see it's not
quite drawn perfectly.

1546
01:14:39,890 --> 01:14:42,230
This is supposed to touch here.

1547
01:14:42,230 --> 01:14:44,810
This guy is floating
a little bit.

1548
01:14:44,810 --> 01:14:48,155
And what we end up, this
guy's uniquely placed.

1549
01:14:48,155 --> 01:14:50,530
And then these guys have got
to go in the three remaining

1550
01:14:50,530 --> 01:14:51,030
pockets.

1551
01:14:51,030 --> 01:14:55,190
What we end up getting is
another equilateral whole

1552
01:14:55,190 --> 01:14:56,610
pocket right there.

1553
01:14:56,610 --> 01:15:00,400
And these three will have the
same size and be identical.

1554
01:15:00,400 --> 01:15:02,330
If I do that in
all four of these,

1555
01:15:02,330 --> 01:15:05,150
now I'll have 16 pockets.

1556
01:15:05,150 --> 01:15:07,400
And each time I do
this, side I quadruple

1557
01:15:07,400 --> 01:15:09,270
the number of pockets.

1558
01:15:09,270 --> 01:15:12,020
So after I do it,
whatever log n times,

1559
01:15:12,020 --> 01:15:13,970
or I apply that
gadget around n times,

1560
01:15:13,970 --> 01:15:16,520
I get around n over 3 pockets.

1561
01:15:16,520 --> 01:15:17,520
They're all identical.

1562
01:15:17,520 --> 01:15:19,770
The ones I don't want, I'll
just throw a disk in there

1563
01:15:19,770 --> 01:15:21,770
to destroy it.

1564
01:15:21,770 --> 01:15:23,517
That's the infrastructure.

1565
01:15:23,517 --> 01:15:25,350
Now I've got n over
three identical pockets.

1566
01:15:25,350 --> 01:15:26,700
There are these other pockets.

1567
01:15:26,700 --> 01:15:28,035
Just throw in disks in there.

1568
01:15:28,035 --> 01:15:29,660
I mean, I can't force
them to go there.

1569
01:15:29,660 --> 01:15:31,700
But if you set disks
to the right size,

1570
01:15:31,700 --> 01:15:33,710
they really have to go there.

1571
01:15:33,710 --> 01:15:36,160
And so all of the other
pockets will get even tinier.

1572
01:15:36,160 --> 01:15:39,267
It will destroy them.

1573
01:15:39,267 --> 01:15:40,350
That's the infrastructure.

1574
01:15:40,350 --> 01:15:41,954
It's already pretty crazy.

1575
01:15:41,954 --> 01:15:43,620
But then the last
part is actually kind,

1576
01:15:43,620 --> 01:15:48,637
is very cool and elegant.

1577
01:15:48,637 --> 01:15:50,095
So I've got these
n over 3 pockets.

1578
01:15:50,095 --> 01:15:54,340

1579
01:15:54,340 --> 01:15:56,329
And this was the central
idea we started with.

1580
01:15:56,329 --> 01:15:58,120
It actually took us
awhile to find this way

1581
01:15:58,120 --> 01:16:00,322
to force a bunch of
identical pockets.

1582
01:16:00,322 --> 01:16:02,280
It's easy if you start
from a triangle of paper

1583
01:16:02,280 --> 01:16:03,370
or a rectangle of paper.

1584
01:16:03,370 --> 01:16:05,710
But we really wanted
to start from a square.

1585
01:16:05,710 --> 01:16:08,060
So that's the case we
care about in origami.

1586
01:16:08,060 --> 01:16:11,080
And so we came up
with that proof.

1587
01:16:11,080 --> 01:16:15,340
This is hard to draw perfectly.

1588
01:16:15,340 --> 01:16:17,450
Here's an equilateral
triangle, so to speak,

1589
01:16:17,450 --> 01:16:20,810
of equal radius disks
pairwise kissing.

1590
01:16:20,810 --> 01:16:23,166
A little slightly
wrong aspect ratio.

1591
01:16:23,166 --> 01:16:24,040
But you get the idea.

1592
01:16:24,040 --> 01:16:27,300

1593
01:16:27,300 --> 01:16:30,660
I'm going to put a disk here
that has a little bit of slack.

1594
01:16:30,660 --> 01:16:33,740

1595
01:16:33,740 --> 01:16:39,405
I'm going to put a disk
here that-- actually, I'm

1596
01:16:39,405 --> 01:16:41,030
going to draw them
without slack first.

1597
01:16:41,030 --> 01:16:43,060
And then I'm going to
say how the slack is.

1598
01:16:43,060 --> 01:16:45,120
Because that'll be
clearer what I mean.

1599
01:16:45,120 --> 01:16:47,810
So suppose this guy was
actually kissing all three.

1600
01:16:47,810 --> 01:16:51,574
And this guy was
kissing three and it's

1601
01:16:51,574 --> 01:16:53,765
like a bunch of threesomes here.

1602
01:16:53,765 --> 01:16:58,350
All right, now I want to
make each of these disks

1603
01:16:58,350 --> 01:17:02,170
a little bit bigger, which
will make this impossible.

1604
01:17:02,170 --> 01:17:05,600
But then I'm going to make
this guy a little bit smaller.

1605
01:17:05,600 --> 01:17:11,245
So I'm going to make
this one a_i bigger.

1606
01:17:11,245 --> 01:17:13,420
I'm going to make
this one a_j bigger.

1607
01:17:13,420 --> 01:17:16,650

1608
01:17:16,650 --> 01:17:20,194
I'm going to make
this one a_k bigger.

1609
01:17:20,194 --> 01:17:23,120

1610
01:17:23,120 --> 01:17:30,590
And this one, what did
I call it, L, smaller.

1611
01:17:30,590 --> 01:17:39,790
So L is the target
sum for a triple,

1612
01:17:39,790 --> 01:17:43,070
meaning I take all the
integers that I'm given.

1613
01:17:43,070 --> 01:17:47,290
And I add them all up.

1614
01:17:47,290 --> 01:17:49,080
And then I divide by n over 3.

1615
01:17:49,080 --> 01:17:50,810
That's what every
triple should sum to.

1616
01:17:50,810 --> 01:17:53,270
Because they're all
supposed to be the same.

1617
01:17:53,270 --> 01:17:57,500
So I call that L. This is
the sum divided by n over 3.

1618
01:17:57,500 --> 01:18:00,320

1619
01:18:00,320 --> 01:18:03,380
So I'm going to make this
one that much smaller.

1620
01:18:03,380 --> 01:18:05,210
This is all slightly
approximate.

1621
01:18:05,210 --> 01:18:06,250
Bear with me.

1622
01:18:06,250 --> 01:18:08,180
So that gives it a
little bit of slack,

1623
01:18:08,180 --> 01:18:10,890
which is good because these
guys are little bit bigger.

1624
01:18:10,890 --> 01:18:16,290
And if they are bigger, in total
if the sum of these two values

1625
01:18:16,290 --> 01:18:19,100
is L, this will barely fit.

1626
01:18:19,100 --> 01:18:21,110
If it's bigger than
L, it won't fit.

1627
01:18:21,110 --> 01:18:24,210
If it's less than
L, it will fit.

1628
01:18:24,210 --> 01:18:27,470
But because L has
to be, L is always

1629
01:18:27,470 --> 01:18:31,170
the average sum of the
triples, if they're all

1630
01:18:31,170 --> 01:18:33,260
going to-- if you have
a bunch of triples,

1631
01:18:33,260 --> 01:18:36,370
all of whose sum is less
than or equal to L, in fact

1632
01:18:36,370 --> 01:18:39,180
they all have to be exactly
equal L. Because there's

1633
01:18:39,180 --> 01:18:40,930
no slack.

1634
01:18:40,930 --> 01:18:43,840
So the only way for these guys
to pack, now I said this is a_i,

1635
01:18:43,840 --> 01:18:47,380
a_j, a_k, in fact I'm just giving
you a heap, a bag of disks.

1636
01:18:47,380 --> 01:18:49,100
I don't say which ones go where.

1637
01:18:49,100 --> 01:18:50,720
You have to choose.

1638
01:18:50,720 --> 01:18:52,449
So clearly, these are
all the same size.

1639
01:18:52,449 --> 01:18:54,240
And they're just going
to go in the center.

1640
01:18:54,240 --> 01:18:56,780
And they'll wiggle
around a little.

1641
01:18:56,780 --> 01:19:01,020
These guys, you get to
choose how I triple them up

1642
01:19:01,020 --> 01:19:03,359
and how I put them into
these n over 3 pockets.

1643
01:19:03,359 --> 01:19:05,150
So that's your flexibility
in disk packing.

1644
01:19:05,150 --> 01:19:07,200
It's your only flexibility
in disk packing,

1645
01:19:07,200 --> 01:19:08,700
is how you triple them up.

1646
01:19:08,700 --> 01:19:10,130
And the only way
for it to work is

1647
01:19:10,130 --> 01:19:13,090
if you can triple them up
so that their sums, the sum

1648
01:19:13,090 --> 01:19:15,020
of the amount by
which they are bigger,

1649
01:19:15,020 --> 01:19:18,070
is exactly L. Because that's
exactly the slack of this disk.

1650
01:19:18,070 --> 01:19:20,240
And it will just fit.

1651
01:19:20,240 --> 01:19:21,165
Question?

1652
01:19:21,165 --> 01:19:24,560
AUDIENCE: So is the fact that you
have an increase in the a_i, j, k,

1653
01:19:24,560 --> 01:19:30,465
summing to L, is a property of the geometry
you can work out with some tangents and stuff?

1654
01:19:30,465 --> 01:19:31,590
PROFESSOR: Yeah, all right.

1655
01:19:31,590 --> 01:19:34,710
So you raise a good point, which
is I said this is a_i bigger.

1656
01:19:34,710 --> 01:19:36,810
I didn't really mean that
the radius is a_i bigger,

1657
01:19:36,810 --> 01:19:40,340
although it's actually
close to that.

1658
01:19:40,340 --> 01:19:41,250
a_i is an integer.

1659
01:19:41,250 --> 01:19:43,820
If I made it that much
bigger, it might be huge.

1660
01:19:43,820 --> 01:19:45,640
But what I really
mean is I take a_i,

1661
01:19:45,640 --> 01:19:49,080
I multiply it by a very small
number greater than zero

1662
01:19:49,080 --> 01:19:50,720
called epsilon.

1663
01:19:50,720 --> 01:19:53,520
And all of these are
actually by epsilon.

1664
01:19:53,520 --> 01:19:56,464
And that is actually how
much you change the radius.

1665
01:19:56,464 --> 01:19:57,880
Maybe there's a
second order term.

1666
01:19:57,880 --> 01:20:01,282
But to the first order, yeah you
think, oh, there's this trig.

1667
01:20:01,282 --> 01:20:03,490
And I've got to do tangents
and all this funny stuff.

1668
01:20:03,490 --> 01:20:05,198
It turns out to the
first order, actually

1669
01:20:05,198 --> 01:20:07,180
things work really simply.

1670
01:20:07,180 --> 01:20:12,349
If I shrink this disk
by an additive amount,

1671
01:20:12,349 --> 01:20:14,640
or sorry, if I grow these
disks by and additive amount,

1672
01:20:14,640 --> 01:20:17,100
I shrink this by
the same amount,

1673
01:20:17,100 --> 01:20:21,660
this will still work up
to the first order, so up

1674
01:20:21,660 --> 01:20:22,660
to the first derivative.

1675
01:20:22,660 --> 01:20:24,660
So you might have to do
a little bit of fudging.

1676
01:20:24,660 --> 01:20:28,940
I can just subtract off an
epsilon squared or something

1677
01:20:28,940 --> 01:20:31,180
to give me just a
little bit of freedom.

1678
01:20:31,180 --> 01:20:33,640
And then this is actually
how big the disks are.

1679
01:20:33,640 --> 01:20:34,770
But you raise a good point.

1680
01:20:34,770 --> 01:20:36,810
There's details I'm hiding here.

1681
01:20:36,810 --> 01:20:38,282
It's actually pretty clean.

1682
01:20:38,282 --> 01:20:39,990
You work out the
tangents and things just

1683
01:20:39,990 --> 01:20:42,070
are pretty, surprisingly.

1684
01:20:42,070 --> 01:20:43,650
We thought this would be messy.

1685
01:20:43,650 --> 01:20:45,472
But it actually
works pretty well.

1686
01:20:45,472 --> 01:20:46,305
Other the questions?

1687
01:20:46,305 --> 01:20:48,920

1688
01:20:48,920 --> 01:20:49,700
All right.

1689
01:20:49,700 --> 01:20:52,670
Now you're experts at
NP-hardness of origami.

1690
01:20:52,670 --> 01:20:56,540

1691
01:20:56,540 --> 01:21:02,950
So here's the not-all-equal
clause gadget.

1692
01:21:02,950 --> 01:21:07,300
And if we fold it here
with all of the incoming

1693
01:21:07,300 --> 01:21:13,020
signals the same direction,
in the center they collide.

1694
01:21:13,020 --> 01:21:15,100
You can't go all
the way to flat.

1695
01:21:15,100 --> 01:21:17,340
This thing is not yet folded.

1696
01:21:17,340 --> 01:21:20,975
And it's stuck in the center.

1697
01:21:20,975 --> 01:21:27,070
But if I flip one of
them, I'll flip this guy,

1698
01:21:27,070 --> 01:21:28,769
then it very happily folds flat.

1699
01:21:28,769 --> 01:21:31,060
Because you don't get that
collision because the center

1700
01:21:31,060 --> 01:21:33,380
ends up going off to the side.

1701
01:21:33,380 --> 01:21:36,152
And you can check that for all
three, it's actually symmetric.

1702
01:21:36,152 --> 01:21:38,610
But no matter how these guys
are set, if they're all equal,

1703
01:21:38,610 --> 01:21:40,400
you get collision in the center.

1704
01:21:40,400 --> 01:21:42,990
If they're not all
equal, it folds flat.

1705
01:21:42,990 --> 01:22:02,477

